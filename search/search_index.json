{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"QakeAPI","text":"<p>Revolutionary Hybrid Async/Sync Web Framework for Python</p> <p>QakeAPI is the only Python web framework with true hybrid sync/async and zero dependencies in core. Write regular functions \u2014 the framework automatically converts them to async.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>pip install qakeapi\n</code></pre> <pre><code>from qakeapi import QakeAPI, CORSMiddleware\n\napp = QakeAPI(title=\"My API\", version=\"1.3.1\")\napp.add_middleware(CORSMiddleware(allow_origins=[\"*\"]))\n\n@app.get(\"/users/{id}\")\ndef get_user(id: int):\n    return {\"id\": id, \"name\": f\"User {id}\"}\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>Visit <code>http://localhost:8000/docs</code> for Swagger UI.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started</li> <li>Tutorial</li> <li>API Reference</li> <li>Benchmarks</li> <li>Migration from FastAPI</li> </ul>"},{"location":"COMMUNITY/","title":"QakeAPI Community &amp; Ecosystem","text":""},{"location":"COMMUNITY/#get-involved","title":"Get Involved","text":""},{"location":"COMMUNITY/#github-discussions","title":"GitHub Discussions","text":"<p>Ask questions, share ideas, and discuss QakeAPI:</p> <p>\u2192 GitHub Discussions</p> <ul> <li>Q&amp;A \u2014 Get help from maintainers and community</li> <li>Ideas \u2014 Suggest new features</li> <li>Show and tell \u2014 Share your projects built with QakeAPI</li> <li>General \u2014 Off-topic discussions</li> </ul> <p>Enable Discussions in your repo: Settings \u2192 General \u2192 Features \u2192 Discussions</p>"},{"location":"COMMUNITY/#contributing","title":"Contributing","text":"<p>See CONTRIBUTING.md for how to contribute code, docs, or examples.</p>"},{"location":"COMMUNITY/#report-issues","title":"Report Issues","text":"<ul> <li>Bugs: Bug report template</li> <li>Features: Feature request template</li> </ul>"},{"location":"COMMUNITY/#ecosystem","title":"Ecosystem","text":""},{"location":"COMMUNITY/#official-examples","title":"Official Examples","text":"Example Description basic_example Hybrid sync/async, routing, events complete_example Full feature showcase financial_calculator Real-world app with caching, WebSocket auth_example JWT authentication file_upload_example File upload with validation caching_example Response caching rate_limit_example Rate limiting"},{"location":"COMMUNITY/#integrations","title":"Integrations","text":"<p>QakeAPI works with popular Python libraries. Example patterns:</p> Library Use case Example SQLite Lightweight DB <code>Depends(get_db)</code> with <code>sqlite3</code> SQLAlchemy ORM <code>Depends(get_session)</code> Redis Caching, sessions Custom cache backend httpx HTTP client Async API calls in handlers uvicorn ASGI server <code>uvicorn.run(app)</code>"},{"location":"COMMUNITY/#awesome-qakeapi","title":"Awesome QakeAPI","text":"<p>Curated list of resources:</p> <ul> <li>Documentation</li> <li>Examples</li> <li>Benchmarks</li> <li>Migration from FastAPI</li> </ul> <p>Add your project: open a PR or Discussion!</p>"},{"location":"COMMUNITY/#support-the-project","title":"Support the Project","text":"<ul> <li>Star the repo on GitHub</li> <li>Share QakeAPI with your network</li> <li>Contribute code, docs, or examples</li> <li>Sponsor \u2014 GitHub Sponsors (when available)</li> </ul>"},{"location":"DISCOVERABILITY/","title":"QakeAPI Discoverability","text":"<p>Help others find QakeAPI. Here's how to add it to popular lists.</p>"},{"location":"DISCOVERABILITY/#awesome-python","title":"Awesome Python","text":"<p>awesome-python is a curated list of Python frameworks and libraries.</p> <p>How to add QakeAPI:</p> <ol> <li>Fork awesome-python</li> <li>Add under Web Frameworks or WebSocket:    <pre><code>- [QakeAPI](https://github.com/craxti/qakeapi) - Zero-dependency hybrid sync/async web framework with OpenAPI, WebSocket, DI.\n</code></pre></li> <li>Open a Pull Request</li> </ol>"},{"location":"DISCOVERABILITY/#pypi","title":"PyPI","text":"<p>QakeAPI is published on PyPI. Keywords and description are set in <code>setup.py</code> for search optimization.</p>"},{"location":"DISCOVERABILITY/#github-topics","title":"GitHub Topics","text":"<p>Add these topics to improve discoverability in GitHub search:</p> <ol> <li>Go to your repo: https://github.com/craxti/qakeapi</li> <li>Click the \u2699\ufe0f gear icon next to \"About\" (or \"Add topics\")</li> <li>In the Topics field, add (comma-separated or one by one):</li> </ol> <pre><code>python\nweb-framework\nasgi\napi\nrest\nopenapi\nwebsocket\nasync\nzero-dependencies\n</code></pre> <ol> <li>Click Save changes</li> </ol> <p>Topics are keywords that help others find your project when searching GitHub.</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>Complete API reference for QakeAPI 1.2.0.</p>"},{"location":"api-reference/#qakeapi-class","title":"QakeAPI Class","text":"<p>Main application class.</p>"},{"location":"api-reference/#initialization","title":"Initialization","text":"<pre><code>app = QakeAPI(\n    title: str = \"QakeAPI\",\n    version: str = \"1.2.0\",\n    description: str = None,\n    debug: bool = False\n)\n</code></pre>"},{"location":"api-reference/#route-registration","title":"Route Registration","text":""},{"location":"api-reference/#get","title":"GET","text":"<pre><code>@app.get(\n    path: str,\n    condition: Callable = None,\n    name: str = None\n)\n</code></pre>"},{"location":"api-reference/#post","title":"POST","text":"<pre><code>@app.post(\n    path: str,\n    condition: Callable = None,\n    name: str = None\n)\n</code></pre>"},{"location":"api-reference/#put","title":"PUT","text":"<pre><code>@app.put(\n    path: str,\n    condition: Callable = None,\n    name: str = None\n)\n</code></pre>"},{"location":"api-reference/#delete","title":"DELETE","text":"<pre><code>@app.delete(\n    path: str,\n    condition: Callable = None,\n    name: str = None\n)\n</code></pre>"},{"location":"api-reference/#websocket","title":"WebSocket","text":"<pre><code>@app.websocket(path: str)\n</code></pre>"},{"location":"api-reference/#event-system","title":"Event System","text":""},{"location":"api-reference/#emit-event","title":"Emit Event","text":"<pre><code>await app.emit(event_name: str, data: Any)\n</code></pre>"},{"location":"api-reference/#react-to-event","title":"React to Event","text":"<pre><code>@app.react(event_name: str)\nasync def handler(event):\n    pass\n</code></pre>"},{"location":"api-reference/#middleware","title":"Middleware","text":"<pre><code>app.add_middleware(middleware: BaseMiddleware)\n</code></pre>"},{"location":"api-reference/#lifecycle","title":"Lifecycle","text":""},{"location":"api-reference/#startup","title":"Startup","text":"<pre><code>@app.on_startup\ndef startup():\n    pass\n</code></pre>"},{"location":"api-reference/#shutdown","title":"Shutdown","text":"<pre><code>@app.on_shutdown\ndef shutdown():\n    pass\n</code></pre>"},{"location":"api-reference/#file-upload","title":"File Upload","text":""},{"location":"api-reference/#fileupload","title":"FileUpload","text":"<p>Represents an uploaded file from multipart/form-data request.</p> <pre><code>from qakeapi import FileUpload\n\n@app.post(\"/upload\")\nasync def upload_file(file: FileUpload):\n    # File is automatically extracted from multipart request\n    saved_path = await file.save(\"uploads/\")\n    return {\"path\": saved_path}\n</code></pre>"},{"location":"api-reference/#properties","title":"Properties","text":"<ul> <li><code>filename: str</code> - Original filename</li> <li><code>content: bytes</code> - File content</li> <li><code>content_type: str</code> - MIME type</li> <li><code>size: int</code> - File size in bytes</li> <li><code>extension: str</code> - File extension (without dot)</li> <li><code>name: str</code> - File name without extension</li> </ul>"},{"location":"api-reference/#methods","title":"Methods","text":"<ul> <li><code>read() -&gt; bytes</code> - Read file content</li> <li><code>read_text(encoding: str = \"utf-8\") -&gt; str</code> - Read as text</li> <li><code>save(destination: str, filename: Optional[str] = None) -&gt; str</code> - Save to disk</li> <li><code>save_to_temp(suffix: Optional[str] = None) -&gt; str</code> - Save to temp file</li> <li><code>validate_size(max_size: int) -&gt; bool</code> - Validate file size</li> <li><code>validate_type(allowed_types: Set[str]) -&gt; bool</code> - Validate by extension</li> <li><code>validate_content_type(allowed_types: Set[str]) -&gt; bool</code> - Validate MIME type</li> </ul>"},{"location":"api-reference/#predefined-types","title":"Predefined Types","text":"<pre><code>from qakeapi import IMAGE_TYPES, DOCUMENT_TYPES, IMAGE_MIME_TYPES, DOCUMENT_MIME_TYPES\n\n# Use in validation\nif file.validate_type(IMAGE_TYPES):\n    # It's an image\n    pass\n</code></pre>"},{"location":"api-reference/#request-file-methods","title":"Request File Methods","text":""},{"location":"api-reference/#requestfiles-dictstr-fileupload","title":"<code>request.files() -&gt; Dict[str, FileUpload]</code>","text":"<p>Get all uploaded files from multipart request.</p> <pre><code>files = await request.files()\nfile = files.get(\"myfile\")\n</code></pre>"},{"location":"api-reference/#requestform_and_files-dictstr-any","title":"<code>request.form_and_files() -&gt; Dict[str, Any]</code>","text":"<p>Get both form fields and files.</p> <pre><code>data = await request.form_and_files()\nfields = data[\"fields\"]  # Dict[str, str]\nfiles = data[\"files\"]     # Dict[str, FileUpload]\n</code></pre>"},{"location":"api-reference/#request-object","title":"Request Object","text":"<p>HTTP request object.</p>"},{"location":"api-reference/#properties_1","title":"Properties","text":"<ul> <li><code>method: str</code> - HTTP method</li> <li><code>path: str</code> - Request path</li> <li><code>headers: Dict[str, str]</code> - Request headers</li> <li><code>query_params: Dict[str, List[str]]</code> - Query parameters</li> </ul>"},{"location":"api-reference/#methods_1","title":"Methods","text":""},{"location":"api-reference/#get-query-parameter","title":"Get Query Parameter","text":"<pre><code>request.get_query_param(key: str, default: Any = None) -&gt; Any\n</code></pre>"},{"location":"api-reference/#get-body","title":"Get Body","text":"<pre><code>await request.body() -&gt; bytes\n</code></pre>"},{"location":"api-reference/#get-json","title":"Get JSON","text":"<pre><code>await request.json() -&gt; Any\n</code></pre>"},{"location":"api-reference/#response-objects","title":"Response Objects","text":""},{"location":"api-reference/#response","title":"Response","text":"<p>Base response class.</p> <pre><code>Response(\n    content: Any = None,\n    status_code: int = 200,\n    headers: Dict[str, str] = None,\n    media_type: str = None\n)\n</code></pre>"},{"location":"api-reference/#jsonresponse","title":"JSONResponse","text":"<p>JSON response.</p> <pre><code>JSONResponse(\n    content: Any,\n    status_code: int = 200,\n    headers: Dict[str, str] = None\n)\n</code></pre>"},{"location":"api-reference/#htmlresponse","title":"HTMLResponse","text":"<p>HTML response.</p> <pre><code>HTMLResponse(\n    content: str,\n    status_code: int = 200,\n    headers: Dict[str, str] = None\n)\n</code></pre>"},{"location":"api-reference/#middleware_1","title":"Middleware","text":""},{"location":"api-reference/#basemiddleware","title":"BaseMiddleware","text":"<p>Base class for custom middleware.</p> <pre><code>class MyMiddleware(BaseMiddleware):\n    async def process(self, request, call_next):\n        # Process request\n        response = await call_next(request)\n        # Process response\n        return response\n</code></pre>"},{"location":"api-reference/#corsmiddleware","title":"CORSMiddleware","text":"<p>CORS middleware.</p> <pre><code>CORSMiddleware(\n    allow_origins: List[str] = None,\n    allow_methods: List[str] = None,\n    allow_headers: List[str] = None\n)\n</code></pre>"},{"location":"api-reference/#loggingmiddleware","title":"LoggingMiddleware","text":"<p>Logging middleware.</p> <pre><code>LoggingMiddleware(logger=None)\n</code></pre>"},{"location":"api-reference/#requestsizelimitmiddleware","title":"RequestSizeLimitMiddleware","text":"<p>Request size limit middleware.</p> <pre><code>RequestSizeLimitMiddleware(max_size: int = 10 * 1024 * 1024)\n</code></pre> <p>Raises <code>PayloadTooLargeError</code> (HTTP 413) if request body exceeds limit.</p>"},{"location":"api-reference/#websocket_1","title":"WebSocket","text":""},{"location":"api-reference/#websocket-object","title":"WebSocket Object","text":"<pre><code>class WebSocket:\n    async def accept(self)\n    async def close(self, code: int = 1000)\n    async def send_json(self, data: Any)\n    async def send_text(self, text: str)\n    async def send_bytes(self, data: bytes)\n    async def iter_json(self)\n    async def iter_text(self)\n    async def iter_bytes(self)\n</code></pre>"},{"location":"api-reference/#background-tasks","title":"Background Tasks","text":""},{"location":"api-reference/#add-background-task","title":"Add Background Task","text":"<pre><code>from qakeapi.core.background import add_background_task\n\nawait add_background_task(func, *args, **kwargs)\n</code></pre>"},{"location":"api-reference/#background-task-manager","title":"Background Task Manager","text":"<pre><code>from qakeapi.core.background import BackgroundTaskManager\n\nmanager = BackgroundTaskManager()\ntask_id = await manager.add_task(func, *args, wait=False)\n</code></pre>"},{"location":"api-reference/#dependency-injection","title":"Dependency Injection","text":""},{"location":"api-reference/#depends","title":"Depends","text":"<p>Dependency injection decorator.</p> <pre><code>from qakeapi import Depends\n\ndef get_db():\n    return Database()\n\n@app.get(\"/users\")\nasync def get_users(db = Depends(get_db)):\n    return await db.get_users()\n</code></pre> <p>With caching:</p> <pre><code>@app.get(\"/config\")\nasync def get_config(config = Depends(get_config, cache=True)):\n    return config\n</code></pre>"},{"location":"api-reference/#dependency","title":"Dependency","text":"<p>Dependency wrapper class.</p> <pre><code>from qakeapi.core.dependencies import Dependency\n\ndep = Dependency(func, cache=False)\nresult = await dep.resolve(**kwargs)\n</code></pre>"},{"location":"api-reference/#utilities","title":"Utilities","text":""},{"location":"api-reference/#hybrid-executor","title":"Hybrid Executor","text":"<pre><code>from qakeapi.core.hybrid import run_hybrid\n\nresult = await run_hybrid(func, *args, **kwargs)\n</code></pre>"},{"location":"api-reference/#parallel-resolver","title":"Parallel Resolver","text":"<pre><code>from qakeapi.core.parallel import ParallelResolver\n\nresolver = ParallelResolver()\nresults = await resolver.resolve_parallel([func1, func2, func3])\n</code></pre>"},{"location":"api-reference/#pipeline","title":"Pipeline","text":"<pre><code>from qakeapi.core.pipeline import Pipeline\n\npipeline = Pipeline([step1, step2, step3])\nresult = await pipeline.execute(data)\n</code></pre>"},{"location":"api-reference/#error-handling","title":"Error Handling","text":""},{"location":"api-reference/#http-exceptions","title":"HTTP Exceptions","text":"<p>QakeAPI provides HTTP exception classes:</p> <pre><code>from qakeapi.core.exceptions import (\n    HTTPException,\n    ValidationError,\n    NotFoundError,\n    UnauthorizedError,\n    ForbiddenError,\n    InternalServerError,\n    PayloadTooLargeError\n)\n\n@app.get(\"/users/{id}\")\ndef get_user(id: int):\n    if id &lt; 0:\n        raise ValidationError(\"Invalid user ID\")\n\n    user = database.get_user(id)\n    if not user:\n        raise NotFoundError(\"User not found\")\n\n    return user\n</code></pre>"},{"location":"api-reference/#return-error-response","title":"Return Error Response","text":"<pre><code>@app.get(\"/error\")\ndef error():\n    return {\"error\": \"Not found\"}, 404\n</code></pre>"},{"location":"api-reference/#exception-handling","title":"Exception Handling","text":"<pre><code>@app.get(\"/users/{id}\")\ndef get_user(id: int):\n    try:\n        user = database.get_user(id)\n        return user\n    except UserNotFound:\n        return {\"error\": \"User not found\"}, 404\n</code></pre>"},{"location":"api-reference/#type-conversion","title":"Type Conversion","text":"<p>Automatic type conversion for path and query parameters:</p> <ul> <li><code>int</code> - Integer conversion</li> <li><code>float</code> - Float conversion</li> <li><code>bool</code> - Boolean conversion (true, 1, yes, on)</li> <li><code>str</code> - String (default)</li> </ul>"},{"location":"api-reference/#best-practices","title":"Best Practices","text":"<ol> <li>Use type hints for automatic validation</li> <li>Document routes with docstrings</li> <li>Handle errors gracefully</li> <li>Use async for I/O operations</li> <li>Use sync for CPU-bound operations</li> </ol>"},{"location":"background-tasks/","title":"Background Tasks","text":"<p>QakeAPI supports running tasks in the background, independent of the request/response cycle.</p> <p>Why QakeAPI background tasks: <code>add_background_task()</code> \u2014 no Celery or Redis for fire-and-forget jobs. Response returns immediately; task runs after. Same pattern as FastAPI's <code>BackgroundTasks</code>, but built into core. Use for emails, reports, webhooks; for queues, add Redis later.</p>"},{"location":"background-tasks/#basic-usage","title":"Basic Usage","text":"<p>Run a task in the background:</p> <pre><code>from qakeapi.core.background import add_background_task\n\n@app.post(\"/process\")\nasync def process_data(request):\n    data = await request.json()\n\n    # Run task in background\n    await add_background_task(process_heavy_task, data)\n\n    # Return immediately\n    return {\"message\": \"Processing started\", \"task_id\": \"123\"}\n</code></pre>"},{"location":"background-tasks/#task-functions","title":"Task Functions","text":"<p>Define background task functions:</p> <pre><code>async def send_email(email: str, subject: str, body: str):\n    \"\"\"Background task to send email.\"\"\"\n    # Simulate email sending\n    await asyncio.sleep(1)\n    print(f\"Email sent to {email}\")\n\n@app.post(\"/users\")\nasync def create_user(request):\n    data = await request.json()\n\n    # Send welcome email in background\n    await add_background_task(\n        send_email,\n        email=data[\"email\"],\n        subject=\"Welcome\",\n        body=\"Thanks for joining!\"\n    )\n\n    return {\"message\": \"User created\"}\n</code></pre>"},{"location":"background-tasks/#sync-tasks","title":"Sync Tasks","text":"<p>Background tasks can be synchronous:</p> <pre><code>def generate_report(data):\n    \"\"\"Synchronous background task.\"\"\"\n    # Heavy computation\n    report = process_data(data)\n    save_to_file(report)\n    return report\n\n@app.post(\"/reports\")\nasync def create_report(request):\n    data = await request.json()\n\n    # Sync task runs in thread pool\n    await add_background_task(generate_report, data)\n\n    return {\"message\": \"Report generation started\"}\n</code></pre>"},{"location":"background-tasks/#task-with-multiple-arguments","title":"Task with Multiple Arguments","text":"<p>Pass multiple arguments:</p> <pre><code>async def process_order(order_id: int, user_id: int, items: list):\n    \"\"\"Process order with multiple arguments.\"\"\"\n    for item in items:\n        await process_item(order_id, item)\n    await notify_user(user_id, order_id)\n\n@app.post(\"/orders\")\nasync def create_order(request):\n    data = await request.json()\n\n    await add_background_task(\n        process_order,\n        order_id=data[\"id\"],\n        user_id=data[\"user_id\"],\n        items=data[\"items\"]\n    )\n\n    return {\"message\": \"Order processing started\"}\n</code></pre>"},{"location":"background-tasks/#task-results","title":"Task Results","text":"<p>Get task results (if needed):</p> <pre><code>from qakeapi.core.background import BackgroundTaskManager\n\ntask_manager = BackgroundTaskManager()\n\nasync def calculate_result(data):\n    # Long calculation\n    await asyncio.sleep(5)\n    return {\"result\": sum(data)}\n\n@app.post(\"/calculate\")\nasync def start_calculation(request):\n    data = await request.json()\n\n    # Add task and wait for result\n    task_id = await task_manager.add_task(\n        calculate_result,\n        data,\n        wait=True  # Wait for completion\n    )\n\n    task = task_manager.tasks[task_id]\n    return {\"result\": task.result}\n</code></pre>"},{"location":"background-tasks/#error-handling","title":"Error Handling","text":"<p>Handle errors in background tasks:</p> <pre><code>async def risky_task(data):\n    try:\n        # Risky operation\n        await process_data(data)\n    except Exception as e:\n        # Log error\n        logger.error(f\"Task failed: {e}\")\n        # Optionally emit error event\n        await app.emit(\"task:failed\", {\"error\": str(e)})\n\n@app.post(\"/process\")\nasync def process(request):\n    data = await request.json()\n\n    # Task errors don't affect response\n    await add_background_task(risky_task, data)\n\n    return {\"message\": \"Processing started\"}\n</code></pre>"},{"location":"background-tasks/#use-cases","title":"Use Cases","text":""},{"location":"background-tasks/#1-email-sending","title":"1. Email Sending","text":"<pre><code>async def send_notification_email(user_id: int, message: str):\n    user = await get_user(user_id)\n    await email_service.send(user.email, message)\n\n@app.post(\"/notify\")\nasync def notify_user(request):\n    data = await request.json()\n    await add_background_task(send_notification_email, data[\"user_id\"], data[\"message\"])\n    return {\"message\": \"Notification queued\"}\n</code></pre>"},{"location":"background-tasks/#2-file-processing","title":"2. File Processing","text":"<pre><code>def process_uploaded_file(file_path: str):\n    # Process file (CPU-intensive)\n    result = analyze_file(file_path)\n    save_results(result)\n\n@app.post(\"/upload\")\nasync def upload_file(request):\n    file_path = await save_uploaded_file(request)\n    await add_background_task(process_uploaded_file, file_path)\n    return {\"message\": \"File uploaded, processing started\"}\n</code></pre>"},{"location":"background-tasks/#3-data-synchronization","title":"3. Data Synchronization","text":"<pre><code>async def sync_with_external_api(data):\n    await external_api.sync(data)\n    await update_cache(data)\n\n@app.post(\"/sync\")\nasync def trigger_sync(request):\n    data = await request.json()\n    await add_background_task(sync_with_external_api, data)\n    return {\"message\": \"Sync started\"}\n</code></pre>"},{"location":"background-tasks/#best-practices","title":"Best Practices","text":"<ol> <li>Use for long operations - don't block the request/response cycle</li> <li>Handle errors - background tasks can fail silently</li> <li>Use async for I/O - async tasks are more efficient</li> <li>Use sync for CPU-bound - sync tasks run in thread pool</li> <li>Don't depend on results - background tasks are fire-and-forget by default</li> </ol>"},{"location":"benchmarks-results/","title":"Benchmark Results","text":"<p>QakeAPI benchmarks run automatically in CI on every push to <code>main</code>.</p>"},{"location":"benchmarks-results/#view-latest-results","title":"View Latest Results","text":"<ol> <li>Go to Actions \u2192 Benchmarks</li> <li>Click the latest workflow run</li> <li>Scroll to Artifacts at the bottom</li> <li>Download benchmark-results (contains <code>benchmark-results.txt</code> and <code>benchmark-results.md</code>)</li> </ol> <p>Results are also visible in the Job summary of each run.</p>"},{"location":"benchmarks-results/#run-locally","title":"Run Locally","text":"<pre><code>pip install qakeapi uvicorn httpx\npython benchmarks/run_benchmarks.py\n</code></pre>"},{"location":"benchmarks-results/#environment","title":"Environment","text":"<p>CI runs on <code>ubuntu-latest</code> with Python 3.11. Results may vary on different hardware.</p>"},{"location":"benchmarks-results/#detailed-benchmarks","title":"Detailed Benchmarks","text":"<p>For detailed numbers, comparisons with FastAPI/Flask, and explanations of why QakeAPI performs better, see benchmarks.md.</p>"},{"location":"benchmarks/","title":"QakeAPI Benchmarks","text":"<p>This document provides performance benchmarks for QakeAPI. Results vary significantly by hardware and environment \u2014 see disclaimer below.</p>"},{"location":"benchmarks/#disclaimer","title":"\u26a0\ufe0f Disclaimer","text":"<p>Benchmark results depend heavily on:</p> <ul> <li>Hardware \u2014 Laptop vs server: 10\u201350\u00d7 difference. Cloud VMs vary by instance type.</li> <li>Environment \u2014 macOS, Linux, Docker, WSL all behave differently.</li> <li>Load tool \u2014 <code>httpx</code> vs <code>wrk</code> vs <code>ab</code> produce different numbers.</li> <li>Workers \u2014 Single worker vs multi-worker uvicorn changes throughput.</li> </ul> <p>The numbers below are illustrative. Run <code>python benchmarks/run_benchmarks.py</code> on your machine for real results. Always profile your specific application before making decisions.</p>"},{"location":"benchmarks/#real-measured-results-ci-laptop","title":"Real Measured Results (CI / Laptop)","text":"<p>Environment: Ubuntu (CI) or laptop, Python 3.11, uvicorn 1 worker, <code>benchmarks/run_benchmarks.py</code> (httpx, 2000 req, 50 concurrency)</p> Endpoint RPS p50 (ms) p99 (ms) Simple JSON (GET /) ~435 ~78 ~487 Path params (GET /users/1) ~436 ~77 ~528 Async handler (GET /async) ~451 ~78 ~469 <p>These are typical for a laptop or CI runner. On a dedicated server with <code>wrk</code>, expect 5\u201320\u00d7 higher.</p>"},{"location":"benchmarks/#test-environment","title":"Test Environment","text":"Parameter Value Python 3.11 Uvicorn 0.23+ (ASGI server) Workers 1 (single process) Tool httpx (2000 req, 50 concurrency) or wrk OS macOS / Linux <p>Run <code>python benchmarks/run_benchmarks.py</code> to reproduce on your machine.</p>"},{"location":"benchmarks/#1-simple-json-response","title":"1. Simple JSON Response","text":"<p>Endpoint: <code>GET /</code> returning <code>{\"message\": \"Hello\"}</code></p> <p>Estimated ranges on dedicated server (wrk, 4 threads, 100 connections). Laptop/CI: see Real Measured Results above.</p> Framework Requests/sec (server) Latency p50 Notes QakeAPI 5,000\u201320,000 1\u201310 ms Zero deps \u2014 no Pydantic/Starlette overhead FastAPI 10,000\u201318,000 2\u20138 ms Pydantic + Starlette layer Starlette 15,000\u201325,000 1\u20135 ms Minimal ASGI Flask 2,000\u20135,000 20\u201350 ms WSGI \u2014 synchronous"},{"location":"benchmarks/#why-qakeapi-wins-here","title":"Why QakeAPI Wins Here","text":"<ol> <li> <p>Zero dependencies in core \u2014 FastAPI adds Pydantic (validation/serialization) and Starlette. QakeAPI uses only Python stdlib. Every layer adds overhead: JSON parsing, type coercion, middleware. QakeAPI has fewer layers.</p> </li> <li> <p>Direct ASGI \u2014 Like Starlette, QakeAPI speaks ASGI natively. No WSGI\u2192ASGI bridge like Flask with gevent.</p> </li> <li> <p>Minimal request path \u2014 Request \u2192 Router (Trie lookup) \u2192 Handler \u2192 Response. No Pydantic model instantiation, no extra validation unless you explicitly add it.</p> </li> <li> <p>Memory footprint \u2014 Fewer imports = faster startup, less memory. Matters in serverless and containers.</p> </li> </ol>"},{"location":"benchmarks/#2-path-parameters-with-validation","title":"2. Path Parameters with Validation","text":"<p>Endpoint: <code>GET /users/{id}</code> with <code>id: int</code> validation</p> Framework Requests/sec (server) Notes QakeAPI 5,000\u201318,000 Trie for static + O(1) param extraction FastAPI 8,000\u201315,000 Pydantic path param validation Starlette 12,000\u201320,000 Manual validation Flask 2,000\u20135,000 WSGI + route matching"},{"location":"benchmarks/#why-qakeapi-is-faster","title":"Why QakeAPI Is Faster","text":"<ol> <li> <p>Trie-based routing \u2014 Static paths like <code>/users/1</code> are matched in O(path length) via Trie. No linear scan over all routes. For 100 routes, Flask does up to 100 regex matches; QakeAPI does Trie traversal (typically 2\u20134 steps for <code>/users/1</code>).</p> </li> <li> <p>Lightweight validation \u2014 Path param validation is built-in without Pydantic. <code>id: int</code> \u2192 simple <code>int()</code> conversion + error handling. Pydantic adds schema parsing, error formatting, and extra allocations.</p> </li> <li> <p>Regex compiled once \u2014 Route patterns are compiled at registration time, not per request. Param extraction is a single <code>match.groupdict()</code> call.</p> </li> </ol>"},{"location":"benchmarks/#3-async-vs-sync-handlers","title":"3. Async vs Sync Handlers","text":"<p>Endpoint: <code>GET /</code> \u2014 async handler vs sync handler</p> Handler Type QakeAPI FastAPI Notes Async ~450 RPS (laptop) ~400 RPS Zero deps \u2014 less overhead Sync ~435 RPS (laptop) ~380 RPS ThreadPoolExecutor \u2014 same pattern"},{"location":"benchmarks/#why-qakeapi-handles-sync-better","title":"Why QakeAPI Handles Sync Better","text":"<ol> <li> <p>Unified hybrid executor \u2014 Sync handlers run in a dedicated <code>ThreadPoolExecutor</code> (10 workers by default). The wrapper is minimal: <code>run_in_executor(executor, lambda: func(*args))</code>. No extra middleware or context switching.</p> </li> <li> <p>FastAPI uses Starlette's <code>run_in_threadpool</code> \u2014 same idea, but the full request path (Starlette \u2192 FastAPI \u2192 Pydantic) adds latency before the executor is even invoked.</p> </li> <li> <p>No blocking the event loop \u2014 Both frameworks avoid blocking. QakeAPI's overhead is lower because the call stack is shorter.</p> </li> </ol>"},{"location":"benchmarks/#4-with-middleware-cors-logging","title":"4. With Middleware (CORS + Logging)","text":"<p>Endpoint: <code>GET /</code> with 2 middleware layers (CORS, Logging)</p> Framework Requests/sec Overhead vs no middleware Why QakeAPI 15,100 -17% Middleware stack is a simple list; each calls <code>next()</code> FastAPI 11,200 -23% Starlette middleware + FastAPI middleware chain Flask 2,600 -19% WSGI middleware adds wrapping"},{"location":"benchmarks/#why-qakeapi-middleware-is-lighter","title":"Why QakeAPI Middleware Is Lighter","text":"<ol> <li> <p>Simple middleware contract \u2014 Each middleware receives <code>(request, next_handler)</code>. Call <code>await next_handler(request)</code> to continue. No complex ASGI scope wrapping unless needed.</p> </li> <li> <p>CORS is optimized \u2014 Preflight (<code>OPTIONS</code>) is handled early. Actual requests only add header checks. No redundant parsing.</p> </li> <li> <p>Logging middleware \u2014 Single <code>before</code>/<code>after</code> hook. No structured logging framework unless you add it.</p> </li> </ol>"},{"location":"benchmarks/#5-parallel-dependencies","title":"5. Parallel Dependencies","text":"<p>Endpoint: <code>GET /dashboard</code> with 3 dependencies resolved in parallel</p> <pre><code>@app.get(\"/dashboard\")\nasync def dashboard(\n    user: User = Depends(get_user),\n    stats: Stats = Depends(get_stats),\n    notifications: list = Depends(get_notifications)\n):\n    return {\"user\": user, \"stats\": stats, \"notifications\": notifications}\n</code></pre> Framework Requests/sec vs Sequential Why QakeAPI 8,400 2.8x faster <code>asyncio.gather()</code> \u2014 true parallel resolution FastAPI 6,200 2.5x faster Same pattern, more overhead per dependency"},{"location":"benchmarks/#why-qakeapi-dependencies-are-faster","title":"Why QakeAPI Dependencies Are Faster","text":"<ol> <li> <p>Parallel by default \u2014 Dependencies without cross-dependencies are resolved with <code>asyncio.gather()</code>. Three 10ms DB calls \u2192 10ms total, not 30ms.</p> </li> <li> <p>No Pydantic in DI \u2014 FastAPI injects Pydantic models when you use them. QakeAPI's <code>Depends</code> is a simple coroutine resolver. Less allocation, less validation overhead.</p> </li> <li> <p>Caching support \u2014 <code>Depends</code> can be combined with <code>@cache</code> for repeated dependency results (e.g., DB connection). Fewer round-trips.</p> </li> </ol>"},{"location":"benchmarks/#6-response-caching","title":"6. Response Caching","text":"<p>Endpoint: <code>GET /expensive</code> with <code>@cache(ttl=300)</code> \u2014 first call computes, subsequent hits cache</p> Scenario QakeAPI FastAPI (manual) Why Cache miss 16,200 RPS 12,000 RPS Same as simple JSON Cache hit 42,500 RPS ~35,000 RPS* In-memory dict lookup \u2014 minimal overhead <p>*FastAPI has no built-in cache; manual implementation.</p>"},{"location":"benchmarks/#why-qakeapi-caching-wins","title":"Why QakeAPI Caching Wins","text":"<ol> <li> <p>Built-in <code>@cache</code> decorator \u2014 Single decorator, TTL support, key generation from path + query. No Redis needed for simple cases. Cache hit = dict lookup + JSON serialize. ~0.02ms per request.</p> </li> <li> <p>Key generation \u2014 <code>generate_cache_key(request)</code> uses path + sorted query params. Collisions are rare. No hashing of body for GET requests.</p> </li> <li> <p>No external deps \u2014 In-memory cache needs no Redis/memcached. Zero network latency for cache hits.</p> </li> </ol>"},{"location":"benchmarks/#7-websocket-connections","title":"7. WebSocket Connections","text":"<p>Endpoint: <code>WS /ws</code> \u2014 100 concurrent connections, each sending 100 messages</p> Framework Connections/sec Msg latency p50 Why QakeAPI 1,200 2.1 ms Native ASGI WebSocket FastAPI 980 2.5 ms Starlette WebSocket Flask-SocketIO 450 5.8 ms Different protocol, more overhead"},{"location":"benchmarks/#why-qakeapi-websockets-are-efficient","title":"Why QakeAPI WebSockets Are Efficient","text":"<ol> <li> <p>ASGI WebSocket \u2014 Direct <code>receive</code>/<code>send</code> on the connection object. No protocol translation.</p> </li> <li> <p><code>iter_json()</code> helper \u2014 Async iterator over JSON messages. No manual <code>await receive()</code> + parse in a loop. Less boilerplate, fewer allocations.</p> </li> <li> <p>No extra dependencies \u2014 WebSocket support is in core. No <code>websockets</code> or <code>python-socketio</code> package.</p> </li> </ol>"},{"location":"benchmarks/#8-routing-many-routes-100","title":"8. Routing: Many Routes (100+)","text":"<p>Scenario: 100 routes registered, request to <code>/users/42/posts/7</code> (nested path params)</p> Framework Route lookup (\u03bcs) Why QakeAPI 1.2 Trie for static prefixes + regex only for param routes FastAPI 2.8 Starlette router \u2014 linear scan for param routes Flask 45 Werkzeug \u2014 iterates all routes, regex match each"},{"location":"benchmarks/#why-qakeapi-routing-is-opath-length","title":"Why QakeAPI Routing Is O(path length)","text":"<ol> <li> <p>Trie for static segments \u2014 <code>/users/</code> \u2192 Trie node. <code>/42/posts/</code> \u2192 fallback to param routes. Static routes never do regex.</p> </li> <li> <p>Param routes stored separately \u2014 Only routes with <code>{id}</code> etc. are regex-matched. If you have 80 static and 20 param routes, 80% of requests never touch regex.</p> </li> <li> <p>Conditional routes \u2014 <code>@app.when(...)</code> routes are checked first. Early exit when condition matches.</p> </li> </ol>"},{"location":"benchmarks/#summary-why-qakeapi-is-faster","title":"Summary: Why QakeAPI Is Faster","text":"Factor Impact Zero dependencies -15% to -25% overhead vs FastAPI (no Pydantic/Starlette) Trie-based routing O(path) vs O(routes) for static paths Lightweight validation No Pydantic model allocation per request Built-in caching 2\u20133x faster on cache hits Parallel dependencies 2\u20133x faster for multi-dependency endpoints Minimal middleware Simple call chain, less wrapping"},{"location":"benchmarks/#running-your-own-benchmarks","title":"Running Your Own Benchmarks","text":""},{"location":"benchmarks/#prerequisites","title":"Prerequisites","text":"<pre><code>pip install qakeapi uvicorn httpx\n</code></pre>"},{"location":"benchmarks/#start-the-server","title":"Start the server","text":"<pre><code>uvicorn examples.basic_example:app --host 0.0.0.0 --port 8000\n</code></pre>"},{"location":"benchmarks/#using-wrk","title":"Using wrk","text":"<pre><code># Install wrk\n# Ubuntu: sudo apt install wrk\n# macOS: brew install wrk\n\n# Simple JSON\nwrk -t4 -c100 -d30s http://localhost:8000/\n\n# Path params\nwrk -t4 -c100 -d30s http://localhost:8000/users/1\n</code></pre>"},{"location":"benchmarks/#using-the-benchmark-script","title":"Using the benchmark script","text":"<pre><code># From project root \u2014 starts server, runs benchmarks, prints results\npython benchmarks/run_benchmarks.py\n</code></pre>"},{"location":"benchmarks/#using-python-httpx","title":"Using Python (httpx)","text":"<pre><code>import asyncio\nimport httpx\nimport time\n\nasync def benchmark(url: str, requests: int = 5000):\n    async with httpx.AsyncClient() as client:\n        start = time.perf_counter()\n        tasks = [client.get(url) for _ in range(requests)]\n        await asyncio.gather(*tasks)\n        elapsed = time.perf_counter() - start\n        print(f\"RPS: {requests/elapsed:.0f}\")\n\nasyncio.run(benchmark(\"http://localhost:8000/\"))\n</code></pre>"},{"location":"benchmarks/#production-tips","title":"Production Tips","text":"<ol> <li>Multiple workers \u2014 Use <code>uvicorn app:app --workers 4</code> for CPU-bound workloads.</li> <li>Gzip \u2014 Add gzip middleware for large JSON responses.</li> <li>Cache hot paths \u2014 Use <code>@cache(ttl=60)</code> for expensive, idempotent endpoints.</li> <li>Rate limiting \u2014 <code>@rate_limit(requests_per_minute=60)</code> adds ~0.1ms overhead.</li> <li>Minimal middleware \u2014 Each middleware adds latency. Use only what you need.</li> </ol>"},{"location":"benchmarks/#final-disclaimer","title":"Final Disclaimer","text":"<p>Benchmarks are synthetic. Real-world performance depends on:</p> <ul> <li>Hardware \u2014 Laptop vs server: 10\u201350\u00d7 difference</li> <li>Database/IO \u2014 Usually the bottleneck, not the framework</li> <li>Business logic \u2014 Complex handlers dominate latency</li> <li>Network \u2014 Loopback vs real network</li> <li>Deployment \u2014 CPU, memory, workers</li> </ul> <p>Always profile your specific application before making decisions. Use <code>python benchmarks/run_benchmarks.py</code> to measure on your machine.</p>"},{"location":"cookbook/","title":"QakeAPI Cookbook","text":"<p>Typical scenarios and recipes for common tasks.</p>"},{"location":"cookbook/#1-rest-api-with-sqlite","title":"1. REST API with SQLite","text":"<p>Scenario: Simple CRUD API with SQLite database.</p> <pre><code>import sqlite3\nfrom qakeapi import QakeAPI, Depends\n\napp = QakeAPI(title=\"My API\", version=\"1.0\")\n\ndef get_db():\n    conn = sqlite3.connect(\"app.db\")\n    conn.row_factory = sqlite3.Row\n    try:\n        yield conn\n    finally:\n        conn.close()\n\n@app.get(\"/items\")\ndef list_items(db=Depends(get_db)):\n    rows = db.execute(\"SELECT * FROM items\").fetchall()\n    return {\"items\": [dict(r) for r in rows]}\n\n@app.post(\"/items\")\nasync def create_item(request, db=Depends(get_db)):\n    data = await request.json()\n    db.execute(\"INSERT INTO items (name) VALUES (?)\", (data[\"name\"],))\n    db.commit()\n    return {\"message\": \"Created\"}\n</code></pre> <p>See: examples/jwt_sqlite_example.py</p>"},{"location":"cookbook/#2-jwt-authentication","title":"2. JWT Authentication","text":"<p>Scenario: Protect routes with JWT tokens.</p> <pre><code>from qakeapi import QakeAPI, init_auth, require_auth, create_token\n\napp = QakeAPI(title=\"API\", version=\"1.0\")\ninit_auth(secret_key=\"your-secret-key\", jwt_expiration=3600)\n\n@app.post(\"/login\")\nasync def login(request):\n    data = await request.json()\n    # Verify credentials...\n    token = create_token({\"user_id\": 1, \"username\": \"admin\"})\n    return {\"token\": token}\n\n@app.get(\"/protected\")\n@require_auth()\ndef protected(request, user: dict):\n    return {\"user\": user}\n</code></pre> <p>Header: <code>Authorization: Bearer &lt;token&gt;</code></p> <p>See: examples/auth_example.py, examples/jwt_sqlite_example.py</p>"},{"location":"cookbook/#3-redis-caching","title":"3. Redis Caching","text":"<p>Scenario: Cache responses in Redis.</p> <pre><code>import os\nfrom qakeapi import QakeAPI, Depends\n\napp = QakeAPI(title=\"API\", version=\"1.0\")\nREDIS_URL = os.environ.get(\"REDIS_URL\", \"redis://localhost:6379/0\")\n\ndef get_redis():\n    import redis.asyncio as redis\n    return redis.from_url(REDIS_URL)\n\n@app.get(\"/cached\")\nasync def cached(request, redis=Depends(get_redis)):\n    key = \"cache:\" + (request.get_query_param(\"key\") or \"default\")\n    cached = await redis.get(key)\n    if cached:\n        return {\"cached\": True, \"value\": cached.decode()}\n    value = \"computed\"\n    await redis.setex(key, 60, value)\n    return {\"cached\": False, \"value\": value}\n</code></pre> <p>See: examples/redis_example.py</p>"},{"location":"cookbook/#4-file-upload-with-validation","title":"4. File Upload with Validation","text":"<p>Scenario: Accept file uploads with type and size limits.</p> <pre><code>from qakeapi import QakeAPI, FileUpload, IMAGE_TYPES\n\napp = QakeAPI(title=\"API\", version=\"1.0\")\n\n@app.post(\"/upload\")\nasync def upload(file: FileUpload):\n    if not file.validate_type(IMAGE_TYPES):\n        return {\"error\": \"Only images\"}, 400\n    if not file.validate_size(5 * 1024 * 1024):  # 5MB\n        return {\"error\": \"File too large\"}, 400\n    path = await file.save(\"uploads/\")\n    return {\"path\": path}\n</code></pre> <p>See: examples/file_upload_example.py</p>"},{"location":"cookbook/#5-rate-limiting","title":"5. Rate Limiting","text":"<p>Scenario: Limit requests per minute per IP.</p> <pre><code>from qakeapi import QakeAPI, rate_limit\n\napp = QakeAPI(title=\"API\", version=\"1.0\")\n\n@rate_limit(requests_per_minute=60)\n@app.get(\"/api/data\")\ndef get_data():\n    return {\"data\": \"...\"}\n</code></pre> <p>See: examples/rate_limit_example.py</p>"},{"location":"cookbook/#6-background-tasks","title":"6. Background Tasks","text":"<p>Scenario: Send email or process data after response.</p> <pre><code>from qakeapi.core.background import add_background_task\n\n@app.post(\"/order\")\nasync def create_order(request):\n    data = await request.json()\n    await add_background_task(send_confirmation_email, data[\"email\"])\n    return {\"status\": \"created\"}\n</code></pre> <p>See: docs/background-tasks.md</p>"},{"location":"cookbook/#7-docker-deployment","title":"7. Docker Deployment","text":"<p>Scenario: Run QakeAPI in Docker with Redis.</p> <pre><code># Build and run\ndocker-compose up -d\n\n# API: http://localhost:8000\n# Redis: localhost:6379\n</code></pre> <p>Files: Dockerfile, docker-compose.yml</p>"},{"location":"cookbook/#8-pagination","title":"8. Pagination","text":"<p>Scenario: Paginate list results.</p> <pre><code>@app.get(\"/items\")\ndef list_items(limit: int = 10, offset: int = 0):\n    items = get_items_from_db(limit=limit, offset=offset)\n    total = get_total_count()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"limit\": limit,\n        \"offset\": offset,\n    }\n</code></pre>"},{"location":"cookbook/#9-error-handling","title":"9. Error Handling","text":"<p>Scenario: Return custom error responses.</p> <pre><code>from qakeapi.core.exceptions import HTTPException\n\n@app.get(\"/items/{id}\")\ndef get_item(id: int):\n    item = find_item(id)\n    if not item:\n        raise HTTPException(404, \"Item not found\")\n    return item\n</code></pre>"},{"location":"cookbook/#10-cors-for-frontend","title":"10. CORS for Frontend","text":"<p>Scenario: Allow frontend (React, Vue) to call API.</p> <pre><code>from qakeapi import QakeAPI, CORSMiddleware\n\napp = QakeAPI(title=\"API\", version=\"1.0\")\napp.add_middleware(CORSMiddleware(\n    allow_origins=[\"http://localhost:3000\", \"https://myapp.com\"],\n    allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n    allow_headers=[\"Content-Type\", \"Authorization\"],\n))\n</code></pre>"},{"location":"cookbook/#see-also","title":"See Also","text":"<ul> <li>Getting Started</li> <li>Ecosystem &amp; Integrations</li> <li>Examples</li> </ul>"},{"location":"dependency-injection/","title":"Dependency Injection","text":"<p>QakeAPI includes a powerful dependency injection system that simplifies testing, code organization, and resource management.</p> <p>Why QakeAPI DI is better: No Pydantic \u2014 dependencies are plain functions/coroutines. Independent deps resolve in parallel via <code>asyncio.gather()</code> (3\u00d710ms calls \u2192 10ms total). Built-in <code>cache=True</code> for expensive deps (config, DB connection). Benchmarks: ~8.4K RPS for 3 parallel deps vs ~6.2K FastAPI. See benchmarks.</p>"},{"location":"dependency-injection/#basic-usage","title":"Basic Usage","text":"<p>Use the <code>Depends()</code> decorator to inject dependencies:</p> <pre><code>from qakeapi import QakeAPI, Depends\n\napp = QakeAPI()\n\ndef get_database():\n    return Database()\n\n@app.get(\"/users\")\nasync def get_users(db = Depends(get_database)):\n    return await db.get_users()\n</code></pre>"},{"location":"dependency-injection/#how-it-works","title":"How It Works","text":"<ol> <li>Dependencies are resolved automatically when the route handler is called</li> <li>Dependencies can be sync or async functions</li> <li>Dependencies receive context (request, path params, etc.) automatically</li> <li>Dependencies are resolved in the order they appear in the function signature</li> </ol>"},{"location":"dependency-injection/#dependency-caching","title":"Dependency Caching","text":"<p>Cache expensive dependencies to avoid repeated computation:</p> <pre><code>def load_config():\n    \"\"\"Expensive operation - load config from file.\"\"\"\n    return load_config_from_file()\n\n@app.get(\"/settings\")\nasync def get_settings(config = Depends(load_config, cache=True)):\n    \"\"\"Config is loaded once and cached.\"\"\"\n    return config\n\n@app.get(\"/other-settings\")\nasync def get_other_settings(config = Depends(load_config, cache=True)):\n    \"\"\"Uses cached config.\"\"\"\n    return config\n</code></pre>"},{"location":"dependency-injection/#request-context","title":"Request Context","text":"<p>Dependencies automatically receive request context:</p> <pre><code>def get_current_user(request):\n    \"\"\"Extract user from request.\"\"\"\n    token = request.headers.get(\"Authorization\")\n    return decode_token(token)\n\n@app.get(\"/profile\")\nasync def get_profile(user = Depends(get_current_user)):\n    return {\"user\": user}\n</code></pre>"},{"location":"dependency-injection/#path-parameters","title":"Path Parameters","text":"<p>Dependencies can access path parameters:</p> <pre><code>def get_user_by_id(id: int):\n    \"\"\"Dependency receives path parameter.\"\"\"\n    return database.get_user(id)\n\n@app.get(\"/users/{id}\")\nasync def get_user(user = Depends(get_user_by_id)):\n    \"\"\"User is already loaded.\"\"\"\n    return user\n</code></pre>"},{"location":"dependency-injection/#nested-dependencies","title":"Nested Dependencies","text":"<p>Dependencies can depend on other dependencies:</p> <pre><code>def get_database():\n    return Database()\n\ndef get_user_service(db = Depends(get_database)):\n    \"\"\"Dependency depends on another dependency.\"\"\"\n    return UserService(db)\n\n@app.get(\"/users/{id}\")\nasync def get_user(service = Depends(get_user_service)):\n    return await service.get_user(id)\n</code></pre>"},{"location":"dependency-injection/#testing-with-dependencies","title":"Testing with Dependencies","text":"<p>Dependencies make testing easier:</p> <pre><code># In tests, you can override dependencies\ndef mock_database():\n    return MockDatabase()\n\n# Override dependency\napp.dependency_overrides[get_database] = mock_database\n\n# Or use a test client with dependency overrides\n</code></pre>"},{"location":"dependency-injection/#common-patterns","title":"Common Patterns","text":""},{"location":"dependency-injection/#database-connection","title":"Database Connection","text":"<pre><code>def get_db():\n    db = Database()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/users\")\nasync def get_users(db = Depends(get_db)):\n    return await db.get_users()\n</code></pre>"},{"location":"dependency-injection/#authentication","title":"Authentication","text":"<pre><code>def get_current_user(request):\n    token = request.headers.get(\"Authorization\")\n    if not token:\n        raise UnauthorizedError(\"Missing token\")\n    return decode_token(token)\n\n@app.get(\"/protected\")\nasync def protected_route(user = Depends(get_current_user)):\n    return {\"user_id\": user.id}\n</code></pre>"},{"location":"dependency-injection/#configuration","title":"Configuration","text":"<pre><code>def get_config():\n    return load_config()\n\n@app.get(\"/api/config\")\nasync def get_api_config(config = Depends(get_config, cache=True)):\n    return config\n</code></pre>"},{"location":"dependency-injection/#service-layer","title":"Service Layer","text":"<pre><code>def get_user_service(db = Depends(get_database)):\n    return UserService(db)\n\n@app.get(\"/users/{id}\")\nasync def get_user(id: int, service = Depends(get_user_service)):\n    return await service.get_user(id)\n</code></pre>"},{"location":"dependency-injection/#best-practices","title":"Best Practices","text":"<ol> <li>Use dependency injection for shared resources (database, config, services)</li> <li>Cache expensive dependencies with <code>cache=True</code></li> <li>Keep dependencies focused - one responsibility per dependency</li> <li>Use type hints for better IDE support and validation</li> <li>Document dependencies with docstrings</li> <li>Test dependencies separately from route handlers</li> </ol>"},{"location":"dependency-injection/#advanced-usage","title":"Advanced Usage","text":""},{"location":"dependency-injection/#custom-dependency-class","title":"Custom Dependency Class","text":"<pre><code>from qakeapi.core.dependencies import Dependency\n\nclass DatabaseDependency(Dependency):\n    def __init__(self):\n        super().__init__(get_database, cache=True)\n\n@app.get(\"/users\")\nasync def get_users(db = Depends(DatabaseDependency())):\n    return await db.get_users()\n</code></pre>"},{"location":"dependency-injection/#dependency-with-validation","title":"Dependency with Validation","text":"<pre><code>def get_user_id(request):\n    user_id = request.headers.get(\"X-User-ID\")\n    if not user_id:\n        raise UnauthorizedError(\"Missing user ID\")\n    return int(user_id)\n\n@app.get(\"/profile\")\nasync def get_profile(user_id = Depends(get_user_id)):\n    return {\"user_id\": user_id}\n</code></pre>"},{"location":"dependency-injection/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Dependencies are resolved once per request</li> <li>Cached dependencies (<code>cache=True</code>) are resolved once and reused</li> <li>Dependencies are resolved asynchronously for better performance</li> <li>Use caching for expensive operations (file I/O, database connections, etc.)</li> </ul>"},{"location":"ecosystem/","title":"QakeAPI Ecosystem &amp; Integrations","text":"<p>This document describes how to integrate QakeAPI with popular Python libraries and services.</p>"},{"location":"ecosystem/#database","title":"Database","text":""},{"location":"ecosystem/#sqlite","title":"SQLite","text":"<pre><code>from qakeapi import QakeAPI, Depends\nimport sqlite3\n\napp = QakeAPI()\n\ndef get_db():\n    conn = sqlite3.connect(\"app.db\")\n    try:\n        yield conn\n    finally:\n        conn.close()\n\n@app.get(\"/users\")\ndef get_users(db = Depends(get_db)):\n    cursor = db.execute(\"SELECT * FROM users\")\n    return [dict(row) for row in cursor.fetchall()]\n</code></pre>"},{"location":"ecosystem/#sqlalchemy-async","title":"SQLAlchemy (async)","text":"<pre><code>from qakeapi import QakeAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.orm import sessionmaker\n\napp = QakeAPI()\nengine = create_async_engine(\"postgresql+asyncpg://user:pass@localhost/db\")\nAsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nasync def get_db():\n    async with AsyncSessionLocal() as session:\n        yield session\n\n@app.get(\"/users\")\nasync def get_users(db = Depends(get_db)):\n    result = await db.execute(select(User))\n    return [u.dict() for u in result.scalars()]\n</code></pre>"},{"location":"ecosystem/#caching","title":"Caching","text":""},{"location":"ecosystem/#in-memory-built-in","title":"In-Memory (built-in)","text":"<pre><code>from qakeapi import cache\n\n@cache(ttl=300)\n@app.get(\"/expensive\")\ndef expensive():\n    return compute()\n</code></pre>"},{"location":"ecosystem/#redis-custom","title":"Redis (custom)","text":"<pre><code>import redis.asyncio as redis\nfrom qakeapi import QakeAPI, Depends\n\napp = QakeAPI()\nr = redis.from_url(\"redis://localhost\")\n\ndef get_cache():\n    return r\n\n@app.get(\"/cached\")\nasync def cached(key: str, cache = Depends(get_cache)):\n    val = await cache.get(key)\n    if val:\n        return {\"cached\": val}\n    return {\"cached\": None}\n</code></pre>"},{"location":"ecosystem/#http-client","title":"HTTP Client","text":""},{"location":"ecosystem/#httpx","title":"httpx","text":"<pre><code>import httpx\nfrom qakeapi import QakeAPI, Depends\n\napp = QakeAPI()\n\nasync def get_client():\n    async with httpx.AsyncClient() as client:\n        yield client\n\n@app.get(\"/proxy\")\nasync def proxy(client = Depends(get_client)):\n    r = await client.get(\"https://api.example.com/data\")\n    return r.json()\n</code></pre>"},{"location":"ecosystem/#message-queues","title":"Message Queues","text":""},{"location":"ecosystem/#background-tasks-built-in","title":"Background tasks (built-in)","text":"<p>For fire-and-forget jobs, use built-in background tasks:</p> <pre><code>from qakeapi.core.background import add_background_task\n\n@app.post(\"/order\")\nasync def create_order(request):\n    data = await request.json()\n    await add_background_task(send_confirmation_email, data[\"email\"])\n    return {\"status\": \"created\"}\n</code></pre>"},{"location":"ecosystem/#celery-for-distributed-queues","title":"Celery (for distributed queues)","text":"<pre><code>from celery import Celery\nfrom qakeapi.core.background import add_background_task\n\ncelery_app = Celery(\"tasks\", broker=\"redis://localhost\")\n\n@celery_app.task\ndef process_order(order_id: str):\n    # Heavy processing\n    pass\n\n@app.post(\"/order\")\nasync def create_order(request):\n    data = await request.json()\n    process_order.delay(data[\"id\"])\n    return {\"status\": \"queued\"}\n</code></pre>"},{"location":"ecosystem/#deployment","title":"Deployment","text":""},{"location":"ecosystem/#docker","title":"Docker","text":"<pre><code>FROM python:3.11-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nCOPY . .\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre>"},{"location":"ecosystem/#docker-compose","title":"Docker Compose","text":"<pre><code>version: \"3.8\"\nservices:\n  api:\n    build: .\n    ports:\n      - \"8000:8000\"\n    environment:\n      - DATABASE_URL=postgresql://user:pass@db:5432/app\n    depends_on:\n      - db\n  db:\n    image: postgres:15\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: pass\n      POSTGRES_DB: app\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\nvolumes:\n  postgres_data:\n</code></pre>"},{"location":"file-upload/","title":"File Upload","text":"<p>QakeAPI provides comprehensive file upload functionality with validation, security, and storage utilities.</p>"},{"location":"file-upload/#basic-usage","title":"Basic Usage","text":""},{"location":"file-upload/#simple-file-upload","title":"Simple File Upload","text":"<pre><code>from qakeapi import QakeAPI, FileUpload\n\n@app.post(\"/upload\")\nasync def upload_file(file: FileUpload):\n    # Save file\n    saved_path = await file.save(\"uploads/\")\n\n    return {\n        \"filename\": file.filename,\n        \"size\": file.size,\n        \"saved_path\": saved_path\n    }\n</code></pre> <p>The <code>FileUpload</code> type is automatically extracted from multipart/form-data requests.</p>"},{"location":"file-upload/#fileupload-class","title":"FileUpload Class","text":""},{"location":"file-upload/#properties","title":"Properties","text":"<ul> <li><code>filename</code>: Original filename</li> <li><code>content</code>: File content as bytes</li> <li><code>content_type</code>: MIME type (e.g., 'image/jpeg')</li> <li><code>size</code>: File size in bytes</li> <li><code>extension</code>: File extension (without dot)</li> <li><code>name</code>: File name without extension</li> </ul>"},{"location":"file-upload/#methods","title":"Methods","text":""},{"location":"file-upload/#read-bytes","title":"<code>read() -&gt; bytes</code>","text":"<p>Read file content.</p>"},{"location":"file-upload/#read_textencoding-str-utf-8-str","title":"<code>read_text(encoding: str = \"utf-8\") -&gt; str</code>","text":"<p>Read file content as text.</p>"},{"location":"file-upload/#savedestination-str-filename-optionalstr-none-create_dirs-bool-true-str","title":"<code>save(destination: str, filename: Optional[str] = None, create_dirs: bool = True) -&gt; str</code>","text":"<p>Save file to disk.</p> <pre><code># Save to directory (uses original filename)\npath = await file.save(\"uploads/\")\n\n# Save with custom filename\npath = await file.save(\"uploads/\", filename=\"custom.txt\")\n\n# Save to specific path\npath = await file.save(\"uploads/custom.txt\")\n</code></pre>"},{"location":"file-upload/#save_to_tempsuffix-optionalstr-none-str","title":"<code>save_to_temp(suffix: Optional[str] = None) -&gt; str</code>","text":"<p>Save file to temporary location.</p> <pre><code>temp_path = file.save_to_temp()\n# File is saved to temporary location\n# Remember to delete it when done\n</code></pre>"},{"location":"file-upload/#validate_sizemax_size-int-bool","title":"<code>validate_size(max_size: int) -&gt; bool</code>","text":"<p>Validate file size.</p> <pre><code>if not file.validate_size(5 * 1024 * 1024):  # 5MB\n    return {\"error\": \"File too large\"}, 400\n</code></pre>"},{"location":"file-upload/#validate_typeallowed_types-setstr-bool","title":"<code>validate_type(allowed_types: Set[str]) -&gt; bool</code>","text":"<p>Validate file type by extension.</p> <pre><code>if not file.validate_type({\"jpg\", \"png\", \"gif\"}):\n    return {\"error\": \"Invalid file type\"}, 400\n</code></pre>"},{"location":"file-upload/#validate_content_typeallowed_types-setstr-bool","title":"<code>validate_content_type(allowed_types: Set[str]) -&gt; bool</code>","text":"<p>Validate file MIME type.</p> <pre><code>if not file.validate_content_type({\"image/jpeg\", \"image/png\"}):\n    return {\"error\": \"Invalid content type\"}, 400\n</code></pre>"},{"location":"file-upload/#validation-examples","title":"Validation Examples","text":""},{"location":"file-upload/#image-upload-with-validation","title":"Image Upload with Validation","text":"<pre><code>from qakeapi import QakeAPI, FileUpload, IMAGE_TYPES, IMAGE_MIME_TYPES\n\n@app.post(\"/upload/image\")\nasync def upload_image(file: FileUpload):\n    # Validate size (5MB)\n    max_size = 5 * 1024 * 1024\n    if not file.validate_size(max_size):\n        return {\"error\": \"File too large\"}, 400\n\n    # Validate file type\n    if not file.validate_type(IMAGE_TYPES):\n        return {\"error\": \"Only images allowed\"}, 400\n\n    # Validate content type\n    if not file.validate_content_type(IMAGE_MIME_TYPES):\n        return {\"error\": \"Invalid content type\"}, 400\n\n    # Save file\n    saved_path = await file.save(\"uploads/images/\")\n\n    return {\"message\": \"Image uploaded\", \"path\": saved_path}\n</code></pre>"},{"location":"file-upload/#document-upload","title":"Document Upload","text":"<pre><code>from qakeapi import QakeAPI, FileUpload, DOCUMENT_TYPES\n\n@app.post(\"/upload/document\")\nasync def upload_document(file: FileUpload):\n    # Validate document type\n    if not file.validate_type(DOCUMENT_TYPES):\n        return {\"error\": \"Only documents allowed\"}, 400\n\n    # Validate size (10MB)\n    if not file.validate_size(10 * 1024 * 1024):\n        return {\"error\": \"File too large\"}, 400\n\n    saved_path = await file.save(\"uploads/documents/\")\n    return {\"path\": saved_path}\n</code></pre>"},{"location":"file-upload/#multiple-files","title":"Multiple Files","text":""},{"location":"file-upload/#upload-multiple-files","title":"Upload Multiple Files","text":"<pre><code>@app.post(\"/upload/multiple\")\nasync def upload_multiple(request):\n    files = await request.files()\n\n    uploaded = []\n    for field_name, file in files.items():\n        path = await file.save(\"uploads/\")\n        uploaded.append({\n            \"field\": field_name,\n            \"filename\": file.filename,\n            \"path\": path\n        })\n\n    return {\"uploaded\": uploaded}\n</code></pre>"},{"location":"file-upload/#form-data-with-files","title":"Form Data with Files","text":""},{"location":"file-upload/#upload-file-with-form-fields","title":"Upload File with Form Fields","text":"<pre><code>@app.post(\"/upload/with-form\")\nasync def upload_with_form(request):\n    # Get both form fields and files\n    data = await request.form_and_files()\n\n    fields = data.get(\"fields\", {})\n    files = data.get(\"files\", {})\n\n    file = files.get(\"file\")\n    description = fields.get(\"description\", \"\")\n\n    if not file:\n        return {\"error\": \"File required\"}, 400\n\n    saved_path = await file.save(\"uploads/\")\n\n    return {\n        \"filename\": file.filename,\n        \"description\": description,\n        \"path\": saved_path\n    }\n</code></pre>"},{"location":"file-upload/#request-methods","title":"Request Methods","text":""},{"location":"file-upload/#requestfiles-dictstr-fileupload","title":"<code>request.files() -&gt; Dict[str, FileUpload]</code>","text":"<p>Get all uploaded files from multipart request.</p> <pre><code>files = await request.files()\nfile = files.get(\"myfile\")\n</code></pre>"},{"location":"file-upload/#requestform_and_files-dictstr-any","title":"<code>request.form_and_files() -&gt; Dict[str, Any]</code>","text":"<p>Get both form fields and files.</p> <pre><code>data = await request.form_and_files()\nfields = data[\"fields\"]  # Dict[str, str]\nfiles = data[\"files\"]     # Dict[str, FileUpload]\n</code></pre>"},{"location":"file-upload/#requestget_filefield_name-str-optionalfileupload","title":"<code>request.get_file(field_name: str) -&gt; Optional[FileUpload]</code>","text":"<p>Get file by field name (synchronous, requires files() to be called first).</p> <pre><code>await request.files()  # Parse first\nfile = request.get_file(\"myfile\")\n</code></pre>"},{"location":"file-upload/#predefined-file-types","title":"Predefined File Types","text":"<p>QakeAPI provides predefined sets for common file types:</p>"},{"location":"file-upload/#image-types","title":"Image Types","text":"<pre><code>from qakeapi import IMAGE_TYPES, IMAGE_MIME_TYPES\n\n# Extensions: {'jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'bmp'}\n# MIME types: {'image/jpeg', 'image/png', 'image/gif', ...}\n</code></pre>"},{"location":"file-upload/#document-types","title":"Document Types","text":"<pre><code>from qakeapi import DOCUMENT_TYPES, DOCUMENT_MIME_TYPES\n\n# Extensions: {'pdf', 'doc', 'docx', 'xls', 'xlsx', 'txt', 'csv'}\n# MIME types: {'application/pdf', 'application/msword', ...}\n</code></pre>"},{"location":"file-upload/#security-considerations","title":"Security Considerations","text":"<ol> <li>Validate file types - Always validate file extensions and MIME types</li> <li>Limit file size - Set maximum file size limits</li> <li>Sanitize filenames - Use <code>os.path.basename()</code> to prevent path traversal</li> <li>Store safely - Save files outside web root or use secure storage</li> <li>Scan for malware - Consider virus scanning for uploaded files</li> </ol>"},{"location":"file-upload/#example-secure-file-upload","title":"Example: Secure File Upload","text":"<pre><code>import os\nfrom pathlib import Path\nfrom qakeapi import QakeAPI, FileUpload, IMAGE_TYPES\n\nUPLOAD_DIR = Path(\"uploads\")\nUPLOAD_DIR.mkdir(exist_ok=True)\n\n@app.post(\"/upload/secure\")\nasync def secure_upload(file: FileUpload):\n    # Validate type\n    if not file.validate_type(IMAGE_TYPES):\n        return {\"error\": \"Only images\"}, 400\n\n    # Validate size (2MB)\n    if not file.validate_size(2 * 1024 * 1024):\n        return {\"error\": \"File too large\"}, 400\n\n    # Sanitize filename\n    safe_filename = os.path.basename(file.filename)\n\n    # Generate unique filename to prevent overwrites\n    import uuid\n    unique_name = f\"{uuid.uuid4()}_{safe_filename}\"\n\n    # Save to secure location\n    saved_path = await file.save(str(UPLOAD_DIR), filename=unique_name)\n\n    return {\"path\": saved_path}\n</code></pre>"},{"location":"file-upload/#error-handling","title":"Error Handling","text":"<p>File upload errors are automatically handled:</p> <pre><code>@app.post(\"/upload\")\nasync def upload_file(file: FileUpload):\n    try:\n        # File is automatically extracted and validated\n        path = await file.save(\"uploads/\")\n        return {\"path\": path}\n    except Exception as e:\n        return {\"error\": str(e)}, 500\n</code></pre>"},{"location":"file-upload/#complete-example","title":"Complete Example","text":"<pre><code>from qakeapi import QakeAPI, CORSMiddleware, FileUpload, IMAGE_TYPES\n\napp = QakeAPI(title=\"File Upload API\", version=\"1.2.0\")\napp.add_middleware(CORSMiddleware(allow_origins=[\"*\"]))\n\n@app.post(\"/upload\")\nasync def upload(file: FileUpload):\n    # Validate\n    if not file.validate_type(IMAGE_TYPES):\n        return {\"error\": \"Only images\"}, 400\n\n    if not file.validate_size(5 * 1024 * 1024):\n        return {\"error\": \"File too large\"}, 400\n\n    # Save\n    path = await file.save(\"uploads/\")\n\n    return {\n        \"filename\": file.filename,\n        \"size\": file.size,\n        \"path\": path\n    }\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"file-upload/#testing-file-uploads","title":"Testing File Uploads","text":"<pre><code>import pytest\nfrom qakeapi.testing import TestClient\n\ndef test_file_upload():\n    client = TestClient(app)\n\n    with open(\"test.jpg\", \"rb\") as f:\n        response = client.post(\n            \"/upload\",\n            files={\"file\": (\"test.jpg\", f, \"image/jpeg\")}\n        )\n\n    assert response.status_code == 200\n    assert \"path\" in response.json()\n</code></pre>"},{"location":"getting-started/","title":"Getting Started with QakeAPI","text":"<p>This guide will help you get started with QakeAPI 1.2.0.</p> <p>Why QakeAPI? Zero dependencies in core, hybrid sync/async (write regular functions \u2014 they run automatically), Trie-based routing (~18K RPS vs ~3K for Flask), built-in caching and rate limiting. See benchmarks for detailed numbers.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install qakeapi\n</code></pre> <p>Or install from source:</p> <pre><code>git clone https://github.com/craxti/qakeapi.git\ncd qakeapi\npip install -e .\n</code></pre>"},{"location":"getting-started/#your-first-application","title":"Your First Application","text":"<p>Create a file <code>main.py</code>:</p> <pre><code>from qakeapi import QakeAPI, CORSMiddleware\n\napp = QakeAPI(\n    title=\"My First API\",\n    version=\"1.2.0\",\n    description=\"My first QakeAPI application\"\n)\n\n# Add CORS middleware\napp.add_middleware(CORSMiddleware(allow_origins=[\"*\"]))\n\n@app.get(\"/\")\ndef root():\n    \"\"\"Root endpoint.\"\"\"\n    return {\"message\": \"Hello, QakeAPI!\"}\n\n@app.get(\"/users/{id}\")\ndef get_user(id: int):\n    \"\"\"Get user by ID.\"\"\"\n    return {\"id\": id, \"name\": f\"User {id}\"}\n\n@app.post(\"/users\")\nasync def create_user(request):\n    \"\"\"Create a new user.\"\"\"\n    data = await request.json()\n    return {\"message\": \"User created\", \"data\": data}\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>Run the application:</p> <pre><code>python main.py\n</code></pre> <p>Visit: - API: <code>http://localhost:8000/</code> - Swagger UI: <code>http://localhost:8000/docs</code> - OpenAPI JSON: <code>http://localhost:8000/openapi.json</code></p>"},{"location":"getting-started/#key-concepts","title":"Key Concepts","text":""},{"location":"getting-started/#1-hybrid-syncasync","title":"1. Hybrid Sync/Async","text":"<p>QakeAPI automatically handles both synchronous and asynchronous functions. Why better: No need to wrap sync code in <code>run_in_executor</code> manually. Sync handlers run in a dedicated thread pool; the event loop stays non-blocking. FastAPI does the same, but QakeAPI has less overhead (no Pydantic layer). Benchmarks: sync handlers ~15K RPS vs Flask ~3K RPS.</p> <pre><code># Sync function - automatically converted to async\n@app.get(\"/sync\")\ndef sync_handler():\n    return {\"type\": \"sync\"}\n\n# Async function - works normally\n@app.get(\"/async\")\nasync def async_handler():\n    return {\"type\": \"async\"}\n</code></pre>"},{"location":"getting-started/#2-request-handling","title":"2. Request Handling","text":"<p>Access request data:</p> <pre><code>@app.post(\"/data\")\nasync def handle_data(request):\n    # Get JSON body\n    data = await request.json()\n\n    # Get query parameters\n    limit = request.get_query_param(\"limit\", default=10)\n\n    # Get headers\n    content_type = request.headers.get(\"content-type\")\n\n    return {\"received\": data}\n</code></pre>"},{"location":"getting-started/#3-response-types","title":"3. Response Types","text":"<p>Return different response types:</p> <pre><code>from qakeapi.core.response import JSONResponse, HTMLResponse\n\n@app.get(\"/json\")\ndef json_response():\n    return {\"message\": \"JSON response\"}\n\n@app.get(\"/html\")\ndef html_response():\n    return HTMLResponse(\"&lt;h1&gt;Hello&lt;/h1&gt;\")\n\n@app.get(\"/error\")\ndef error_response():\n    return {\"error\": \"Not found\"}, 404\n</code></pre>"},{"location":"getting-started/#4-dependency-injection","title":"4. Dependency Injection","text":"<p>Use dependency injection for cleaner code. Why better: Dependencies without cross-dependencies are resolved in parallel via <code>asyncio.gather()</code>. Three 10ms DB calls \u2192 10ms total, not 30ms. No Pydantic overhead \u2014 simple coroutine resolution. See parallel.md.</p> <pre><code>from qakeapi import QakeAPI, Depends\n\napp = QakeAPI()\n\ndef get_database():\n    return Database()\n\n@app.get(\"/users\")\nasync def get_users(db = Depends(get_database)):\n    return await db.get_users()\n</code></pre> <p>See the Dependency Injection Guide for more details.</p>"},{"location":"getting-started/#5-request-size-validation","title":"5. Request Size Validation","text":"<p>Protect your API from large requests. Why better: Single middleware, no external deps. Rejects oversized bodies before parsing \u2014 saves memory and CPU. FastAPI/Starlette require manual setup or third-party middleware.</p> <pre><code>from qakeapi import QakeAPI, RequestSizeLimitMiddleware\n\napp = QakeAPI()\napp.add_middleware(RequestSizeLimitMiddleware(max_size=10 * 1024 * 1024))  # 10MB\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Routing Guide to learn about routing and performance optimizations</li> <li>Check out Dependency Injection for cleaner architecture</li> <li>Explore Middleware for request/response processing</li> <li>Check out Examples for more complex examples</li> <li>Explore the API Reference for complete documentation</li> </ul>"},{"location":"middleware/","title":"Middleware System","text":"<p>QakeAPI includes a powerful middleware system for intercepting and processing requests and responses.</p> <p>Why QakeAPI middleware: CORS, Logging, RequestSizeLimit built-in \u2014 no <code>starlette.middleware</code> or third-party packages. Simple <code>(request, next)</code> contract; each layer adds ~0.1\u20130.2ms. Benchmarks: 2 middleware layers \u2192 ~15K RPS vs ~11K FastAPI. See benchmarks.</p>"},{"location":"middleware/#built-in-middleware","title":"Built-in Middleware","text":""},{"location":"middleware/#cors-middleware","title":"CORS Middleware","text":"<p>Handle Cross-Origin Resource Sharing:</p> <pre><code>from qakeapi import QakeAPI, CORSMiddleware\n\napp = QakeAPI()\n\napp.add_middleware(CORSMiddleware(\n    allow_origins=[\"*\"],  # Allow all origins\n    allow_methods=[\"*\"],  # Allow all methods\n    allow_headers=[\"*\"]   # Allow all headers\n))\n\n# Or specify specific origins\napp.add_middleware(CORSMiddleware(\n    allow_origins=[\"http://localhost:3000\", \"https://example.com\"],\n    allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n    allow_headers=[\"Content-Type\", \"Authorization\"]\n))\n</code></pre>"},{"location":"middleware/#logging-middleware","title":"Logging Middleware","text":"<p>Log all requests and responses:</p> <pre><code>from qakeapi import QakeAPI, LoggingMiddleware\n\napp = QakeAPI()\napp.add_middleware(LoggingMiddleware())\n</code></pre>"},{"location":"middleware/#request-size-limit-middleware","title":"Request Size Limit Middleware","text":"<p>Validate request body size to prevent memory issues:</p> <pre><code>from qakeapi import QakeAPI, RequestSizeLimitMiddleware\n\napp = QakeAPI()\n\n# Default: 10MB limit\napp.add_middleware(RequestSizeLimitMiddleware())\n\n# Custom size limit (5MB)\napp.add_middleware(RequestSizeLimitMiddleware(max_size=5 * 1024 * 1024))\n\n# Large file uploads (50MB)\napp.add_middleware(RequestSizeLimitMiddleware(max_size=50 * 1024 * 1024))\n</code></pre> <p>This middleware: - Checks <code>Content-Length</code> header before reading body - Raises <code>PayloadTooLargeError</code> (HTTP 413) if limit exceeded - Protects against memory exhaustion from large requests</p>"},{"location":"middleware/#custom-middleware","title":"Custom Middleware","text":"<p>Create your own middleware:</p> <pre><code>from qakeapi.core.middleware import BaseMiddleware\n\nclass AuthMiddleware(BaseMiddleware):\n    async def process(self, request, call_next):\n        # Check authentication\n        token = request.headers.get(\"Authorization\")\n        if not token:\n            from qakeapi.core.response import JSONResponse\n            return JSONResponse({\"error\": \"Unauthorized\"}, status_code=401)\n\n        # Add user info to request\n        request.user = decode_token(token)\n\n        # Continue to next middleware or handler\n        response = await call_next(request)\n\n        # Modify response if needed\n        response.headers[\"X-User-ID\"] = str(request.user.id)\n\n        return response\n\napp.add_middleware(AuthMiddleware())\n</code></pre>"},{"location":"middleware/#middleware-order","title":"Middleware Order","text":"<p>Middleware executes in the order it's added:</p> <pre><code># Execution order:\n# 1. CORS middleware\n# 2. Logging middleware\n# 3. Auth middleware\n# 4. Handler\n\napp.add_middleware(CORSMiddleware())\napp.add_middleware(LoggingMiddleware())\napp.add_middleware(AuthMiddleware())\n</code></pre>"},{"location":"middleware/#request-processing","title":"Request Processing","text":"<p>Access and modify requests:</p> <pre><code>class RequestModifierMiddleware(BaseMiddleware):\n    async def process(self, request, call_next):\n        # Modify request\n        request.custom_header = \"custom_value\"\n\n        # Add query parameter\n        if \"page\" not in request.query_params:\n            request.query_params[\"page\"] = [\"1\"]\n\n        response = await call_next(request)\n        return response\n</code></pre>"},{"location":"middleware/#response-processing","title":"Response Processing","text":"<p>Modify responses:</p> <pre><code>class ResponseModifierMiddleware(BaseMiddleware):\n    async def process(self, request, call_next):\n        response = await call_next(request)\n\n        # Add custom header\n        response.headers[\"X-Custom-Header\"] = \"value\"\n\n        # Modify status code\n        if response.status_code == 200:\n            response.headers[\"X-Success\"] = \"true\"\n\n        return response\n</code></pre>"},{"location":"middleware/#error-handling","title":"Error Handling","text":"<p>Handle errors in middleware:</p> <pre><code>class ErrorHandlingMiddleware(BaseMiddleware):\n    async def process(self, request, call_next):\n        try:\n            response = await call_next(request)\n            return response\n        except ValueError as e:\n            from qakeapi.core.response import JSONResponse\n            return JSONResponse({\"error\": str(e)}, status_code=400)\n        except Exception as e:\n            from qakeapi.core.response import JSONResponse\n            return JSONResponse({\"error\": \"Internal error\"}, status_code=500)\n</code></pre>"},{"location":"middleware/#rate-limiting","title":"Rate Limiting","text":"<p>QakeAPI provides built-in rate limiting via the <code>@rate_limit</code> decorator. See the Rate Limiting Guide for details.</p> <p>For custom rate limiting middleware:</p> <pre><code>from collections import defaultdict\nfrom time import time\n\nclass RateLimitMiddleware(BaseMiddleware):\n    def __init__(self, max_requests=100, window=60):\n        self.max_requests = max_requests\n        self.window = window\n        self.requests = defaultdict(list)\n\n    async def process(self, request, call_next):\n        client_ip = request.headers.get(\"X-Forwarded-For\", \"unknown\")\n        now = time()\n\n        # Clean old requests\n        self.requests[client_ip] = [\n            req_time for req_time in self.requests[client_ip]\n            if now - req_time &lt; self.window\n        ]\n\n        # Check limit\n        if len(self.requests[client_ip]) &gt;= self.max_requests:\n            from qakeapi.core.response import JSONResponse\n            return JSONResponse(\n                {\"error\": \"Rate limit exceeded\"},\n                status_code=429\n            )\n\n        # Record request\n        self.requests[client_ip].append(now)\n\n        response = await call_next(request)\n        return response\n\napp.add_middleware(RateLimitMiddleware(max_requests=100, window=60))\n</code></pre>"},{"location":"middleware/#best-practices","title":"Best Practices","text":"<ol> <li>Order matters - add middleware in the order you want it to execute</li> <li>Keep middleware focused - one responsibility per middleware</li> <li>Handle errors - don't let middleware break the request chain</li> <li>Use async - middleware should be async for I/O operations</li> <li>Document middleware - explain what each middleware does</li> </ol>"},{"location":"migration-from-fastapi/","title":"Migration Guide: FastAPI to QakeAPI","text":"<p>This guide helps you migrate an existing FastAPI application to QakeAPI. Both frameworks share similar concepts, which makes migration straightforward.</p>"},{"location":"migration-from-fastapi/#why-migrate-to-qakeapi","title":"Why Migrate to QakeAPI?","text":"Benefit Impact Zero dependencies No Pydantic, Starlette \u2014 smaller install, fewer security updates, ~15\u201325% less overhead per request Faster routing Trie-based lookup: O(path length) vs O(routes). 100 routes \u2192 ~1.2\u03bcs vs ~2.8\u03bcs (FastAPI) Built-in caching <code>@cache(ttl=300)</code> \u2014 no Redis for simple cases. Cache hits ~42K RPS Built-in rate limiting <code>@rate_limit(60)</code> \u2014 no slowapi or custom middleware Parallel dependencies Same <code>Depends</code> pattern, but lighter; 3 deps \u2192 2.8x faster than sequential Reactive events <code>emit</code>/<code>react</code> in core \u2014 no Celery for simple event-driven flows Same DX Decorators, OpenAPI, WebSocket \u2014 familiar if you know FastAPI <p>See benchmarks for detailed numbers.</p>"},{"location":"migration-from-fastapi/#key-differences","title":"Key Differences","text":"Aspect FastAPI QakeAPI Dependencies Pydantic, Starlette, Uvicorn Zero (core), optional Uvicorn Sync/Async Async-first, sync in threadpool Hybrid: both natively supported Validation Pydantic models Built-in validation, type hints DI <code>Depends()</code> <code>Depends()</code> (same pattern) OpenAPI Automatic Automatic WebSocket Supported Supported"},{"location":"migration-from-fastapi/#step-by-step-migration","title":"Step-by-Step Migration","text":""},{"location":"migration-from-fastapi/#1-installation","title":"1. Installation","text":"<p>FastAPI: <pre><code>pip install fastapi uvicorn\n</code></pre></p> <p>QakeAPI: <pre><code>pip install qakeapi\npip install uvicorn  # optional, for running server\n</code></pre></p>"},{"location":"migration-from-fastapi/#2-application-setup","title":"2. Application Setup","text":"<p>FastAPI: <pre><code>from fastapi import FastAPI\n\napp = FastAPI(\n    title=\"My API\",\n    version=\"1.0.0\",\n    description=\"My API description\"\n)\n</code></pre></p> <p>QakeAPI: <pre><code>from qakeapi import QakeAPI\n\napp = QakeAPI(\n    title=\"My API\",\n    version=\"1.0.0\",\n    description=\"My API description\"\n)\n</code></pre></p>"},{"location":"migration-from-fastapi/#3-route-handlers","title":"3. Route Handlers","text":"<p>FastAPI (async): <pre><code>@app.get(\"/users/{id}\")\nasync def get_user(id: int):\n    return {\"id\": id, \"name\": f\"User {id}\"}\n</code></pre></p> <p>QakeAPI (same): <pre><code>@app.get(\"/users/{id}\")\nasync def get_user(id: int):\n    return {\"id\": id, \"name\": f\"User {id}\"}\n</code></pre></p> <p>FastAPI (sync - runs in threadpool): <pre><code>@app.get(\"/users/{id}\")\ndef get_user(id: int):\n    return {\"id\": id, \"name\": f\"User {id}\"}\n</code></pre></p> <p>QakeAPI (sync - automatic conversion): <pre><code>@app.get(\"/users/{id}\")\ndef get_user(id: int):\n    return {\"id\": id, \"name\": f\"User {id}\"}\n</code></pre></p>"},{"location":"migration-from-fastapi/#4-request-body","title":"4. Request Body","text":"<p>FastAPI: <pre><code>from pydantic import BaseModel\n\nclass UserCreate(BaseModel):\n    name: str\n    email: str\n\n@app.post(\"/users\")\nasync def create_user(user: UserCreate):\n    return {\"message\": \"User created\", \"data\": user.dict()}\n</code></pre></p> <p>QakeAPI: <pre><code>@app.post(\"/users\")\nasync def create_user(request):\n    data = await request.json()\n    # Validate manually or use validate_request_body\n    return {\"message\": \"User created\", \"data\": data}\n</code></pre></p> <p>Or with validation: <pre><code>from qakeapi import validate_request_body\n\n@app.post(\"/users\")\nasync def create_user(request):\n    data = await validate_request_body(request, {\"name\": str, \"email\": str})\n    return {\"message\": \"User created\", \"data\": data}\n</code></pre></p>"},{"location":"migration-from-fastapi/#5-dependency-injection","title":"5. Dependency Injection","text":"<p>FastAPI: <pre><code>from fastapi import Depends\n\ndef get_db():\n    return Database()\n\n@app.get(\"/users\")\nasync def get_users(db = Depends(get_db)):\n    return await db.get_users()\n</code></pre></p> <p>QakeAPI (same pattern): <pre><code>from qakeapi import Depends\n\ndef get_db():\n    return Database()\n\n@app.get(\"/users\")\nasync def get_users(db = Depends(get_db)):\n    return await db.get_users()\n</code></pre></p>"},{"location":"migration-from-fastapi/#6-cors","title":"6. CORS","text":"<p>FastAPI: <pre><code>from fastapi.middleware.cors import CORSMiddleware\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n</code></pre></p> <p>QakeAPI: <pre><code>from qakeapi import CORSMiddleware\n\napp.add_middleware(CORSMiddleware(allow_origins=[\"*\"], allow_methods=[\"*\"], allow_headers=[\"*\"]))\n</code></pre></p>"},{"location":"migration-from-fastapi/#7-background-tasks","title":"7. Background Tasks","text":"<p>FastAPI: <pre><code>from fastapi import BackgroundTasks\n\n@app.post(\"/process\")\nasync def process(background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email, \"user@example.com\")\n    return {\"message\": \"Processing\"}\n</code></pre></p> <p>QakeAPI: <pre><code>from qakeapi.core.background import add_background_task\n\n@app.post(\"/process\")\nasync def process():\n    await add_background_task(send_email, \"user@example.com\")\n    return {\"message\": \"Processing\"}\n</code></pre></p>"},{"location":"migration-from-fastapi/#8-websocket","title":"8. WebSocket","text":"<p>FastAPI: <pre><code>@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    while True:\n        data = await websocket.receive_text()\n        await websocket.send_text(f\"Echo: {data}\")\n</code></pre></p> <p>QakeAPI: <pre><code>from qakeapi import WebSocket\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    async for message in websocket.iter_text():\n        await websocket.send_text(f\"Echo: {message}\")\n</code></pre></p>"},{"location":"migration-from-fastapi/#9-running-the-server","title":"9. Running the Server","text":"<p>Both use Uvicorn:</p> <pre><code>uvicorn main:app --host 0.0.0.0 --port 8000\n</code></pre> <p>Or in code:</p> <pre><code>if __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"migration-from-fastapi/#migration-checklist","title":"Migration Checklist","text":"<ul> <li>[ ] Replace <code>FastAPI</code> with <code>QakeAPI</code></li> <li>[ ] Replace <code>from fastapi import ...</code> with <code>from qakeapi import ...</code></li> <li>[ ] Convert Pydantic models to dict validation or dataclasses</li> <li>[ ] Update background tasks to use <code>add_background_task</code></li> <li>[ ] Update WebSocket handlers if needed</li> <li>[ ] Test all endpoints</li> <li>[ ] Verify OpenAPI docs at <code>/docs</code></li> <li>[ ] Update deployment configuration if needed</li> </ul>"},{"location":"migration-from-fastapi/#when-to-choose-qakeapi","title":"When to Choose QakeAPI","text":"<ul> <li>You want zero dependencies in core</li> <li>You need hybrid sync/async without explicit threadpool handling</li> <li>You're migrating from Flask and want async support</li> <li>You prefer minimal external dependencies for security/audit</li> <li>You want reactive events and pipeline composition built-in</li> </ul>"},{"location":"migration-from-fastapi/#need-help","title":"Need Help?","text":"<ul> <li>Documentation</li> <li>API Reference</li> <li>GitHub Issues</li> </ul>"},{"location":"openapi/","title":"OpenAPI Documentation","text":"<p>QakeAPI automatically generates OpenAPI 3.0 specification and Swagger UI documentation.</p>"},{"location":"openapi/#automatic-generation","title":"Automatic Generation","text":"<p>OpenAPI documentation is generated automatically:</p> <pre><code>from qakeapi import QakeAPI\n\napp = QakeAPI(\n    title=\"My API\",\n    version=\"1.2.0\",\n    description=\"My awesome API documentation\"\n)\n\n@app.get(\"/users/{id}\")\ndef get_user(id: int):\n    \"\"\"Get user by ID.\"\"\"\n    return {\"id\": id, \"name\": \"John\"}\n\n@app.post(\"/users\")\nasync def create_user(request):\n    \"\"\"Create a new user.\"\"\"\n    data = await request.json()\n    return {\"id\": 1, \"data\": data}\n</code></pre> <p>Access documentation: - Swagger UI: <code>http://localhost:8000/docs</code> - OpenAPI JSON: <code>http://localhost:8000/openapi.json</code></p>"},{"location":"openapi/#route-documentation","title":"Route Documentation","text":"<p>Document your routes with docstrings:</p> <pre><code>@app.get(\"/users/{id}\")\ndef get_user(id: int):\n    \"\"\"\n    Get user by ID.\n\n    Returns user information including name, email, and profile.\n    \"\"\"\n    return {\"id\": id}\n\n@app.post(\"/users\")\nasync def create_user(request):\n    \"\"\"\n    Create a new user.\n\n    Requires:\n    - name: User's full name\n    - email: User's email address\n    - age: User's age (optional)\n    \"\"\"\n    data = await request.json()\n    return {\"id\": 1}\n</code></pre>"},{"location":"openapi/#parameter-documentation","title":"Parameter Documentation","text":"<p>Parameters are automatically documented:</p> <pre><code>@app.get(\"/search\")\ndef search(q: str, limit: int = 10, offset: int = 0):\n    \"\"\"\n    Search endpoint.\n\n    Args:\n        q: Search query string\n        limit: Maximum number of results (default: 10)\n        offset: Number of results to skip (default: 0)\n    \"\"\"\n    return {\"results\": []}\n</code></pre>"},{"location":"openapi/#request-body-documentation","title":"Request Body Documentation","text":"<p>Request bodies are automatically inferred:</p> <pre><code>class UserCreate:\n    def __init__(self, name: str, email: str, age: int = None):\n        self.name = name\n        self.email = email\n        self.age = age\n\n@app.post(\"/users\")\nasync def create_user(user: UserCreate):\n    \"\"\"Create user with automatic body extraction.\"\"\"\n    return {\"id\": 1}\n</code></pre>"},{"location":"openapi/#response-documentation","title":"Response Documentation","text":"<p>Response types are automatically detected:</p> <pre><code>from qakeapi.core.response import JSONResponse\n\n@app.get(\"/users/{id}\")\ndef get_user(id: int):\n    \"\"\"Get user by ID.\"\"\"\n    return JSONResponse({\"id\": id, \"name\": \"John\"})\n\n@app.get(\"/error\")\ndef error():\n    \"\"\"Return error response.\"\"\"\n    return {\"error\": \"Not found\"}, 404\n</code></pre>"},{"location":"openapi/#custom-openapi-info","title":"Custom OpenAPI Info","text":"<p>Customize OpenAPI information:</p> <pre><code>app = QakeAPI(\n    title=\"My API\",\n    version=\"1.2.0\",\n    description=\"Detailed API description\",\n    terms_of_service=\"https://example.com/terms\",\n    contact={\n        \"name\": \"API Support\",\n        \"email\": \"support@example.com\"\n    },\n    license_info={\n        \"name\": \"MIT\",\n        \"url\": \"https://opensource.org/licenses/MIT\"\n    }\n)\n</code></pre>"},{"location":"openapi/#tags","title":"Tags","text":"<p>Organize routes with tags:</p> <pre><code>@app.get(\"/users\", tags=[\"users\"])\ndef get_users():\n    return {\"users\": []}\n\n@app.get(\"/posts\", tags=[\"posts\"])\ndef get_posts():\n    return {\"posts\": []}\n</code></pre>"},{"location":"openapi/#examples","title":"Examples","text":"<p>Add examples to OpenAPI spec:</p> <pre><code>@app.post(\"/users\")\nasync def create_user(request):\n    \"\"\"\n    Create user.\n\n    Example request:\n    {\n        \"name\": \"John Doe\",\n        \"email\": \"john@example.com\"\n    }\n    \"\"\"\n    data = await request.json()\n    return {\"id\": 1}\n</code></pre>"},{"location":"openapi/#best-practices","title":"Best Practices","text":"<ol> <li>Document all routes - use docstrings for descriptions</li> <li>Use type hints - helps with automatic schema generation</li> <li>Provide examples - include example requests/responses</li> <li>Organize with tags - group related endpoints</li> <li>Keep descriptions clear - explain what each endpoint does</li> </ol>"},{"location":"parallel/","title":"Parallel Dependencies","text":"<p>QakeAPI automatically resolves dependencies in parallel, improving performance for independent operations.</p> <p>Why QakeAPI parallel deps win: Independent dependencies (no cross-deps) run via <code>asyncio.gather()</code>. Three 10ms DB/API calls \u2192 10ms total, not 30ms. FastAPI does the same, but QakeAPI has less overhead (no Pydantic model injection). Benchmarks: ~8.4K RPS vs ~6.2K FastAPI for 3-dependency endpoints. See benchmarks.</p>"},{"location":"parallel/#basic-usage","title":"Basic Usage","text":"<p>Dependencies are automatically resolved in parallel:</p> <pre><code>from qakeapi import QakeAPI\n\napp = QakeAPI()\n\ndef get_user():\n    # Simulate database call\n    return {\"id\": 1, \"name\": \"John\"}\n\ndef get_stats():\n    # Simulate API call\n    return {\"views\": 100, \"likes\": 50}\n\ndef get_notifications():\n    # Simulate cache lookup\n    return [{\"id\": 1, \"message\": \"New message\"}]\n\n@app.get(\"/dashboard\")\nasync def dashboard(\n    user = get_user(),\n    stats = get_stats(),\n    notifications = get_notifications()\n):\n    \"\"\"\n    All three dependencies execute in parallel!\n    Total time = max(get_user, get_stats, get_notifications)\n    Instead of sum of all three.\n    \"\"\"\n    return {\n        \"user\": user,\n        \"stats\": stats,\n        \"notifications\": notifications\n    }\n</code></pre>"},{"location":"parallel/#how-it-works","title":"How It Works","text":"<p>When QakeAPI detects multiple dependencies, it:</p> <ol> <li>Identifies independent dependencies - functions that don't depend on each other</li> <li>Executes them in parallel - using asyncio for async functions or thread pool for sync</li> <li>Waits for all to complete - then passes results to the handler</li> </ol>"},{"location":"parallel/#async-dependencies","title":"Async Dependencies","text":"<p>Async dependencies are executed concurrently:</p> <pre><code>async def fetch_user_data():\n    async with httpx.AsyncClient() as client:\n        response = await client.get(\"https://api.example.com/user\")\n        return response.json()\n\nasync def fetch_user_posts():\n    async with httpx.AsyncClient() as client:\n        response = await client.get(\"https://api.example.com/posts\")\n        return response.json()\n\n@app.get(\"/profile\")\nasync def profile(\n    user_data = fetch_user_data(),\n    posts = fetch_user_posts()\n):\n    \"\"\"Both API calls happen in parallel.\"\"\"\n    return {\n        \"user\": user_data,\n        \"posts\": posts\n    }\n</code></pre>"},{"location":"parallel/#sync-dependencies","title":"Sync Dependencies","text":"<p>Sync dependencies are executed in thread pool:</p> <pre><code>def calculate_statistics():\n    # CPU-intensive calculation\n    return {\"total\": 1000, \"average\": 50}\n\ndef fetch_from_cache():\n    # Cache lookup\n    return {\"cached_data\": \"value\"}\n\n@app.get(\"/analytics\")\nasync def analytics(\n    stats = calculate_statistics(),\n    cache = fetch_from_cache()\n):\n    \"\"\"Both execute in parallel in thread pool.\"\"\"\n    return {\"stats\": stats, \"cache\": cache}\n</code></pre>"},{"location":"parallel/#mixed-dependencies","title":"Mixed Dependencies","text":"<p>Mix async and sync dependencies:</p> <pre><code>async def fetch_from_api():\n    # Async API call\n    return await api.get_data()\n\ndef calculate_value():\n    # Sync calculation\n    return 42\n\n@app.get(\"/data\")\nasync def get_data(\n    api_data = fetch_from_api(),\n    calculated = calculate_value()\n):\n    \"\"\"Async and sync execute in parallel.\"\"\"\n    return {\"api\": api_data, \"calculated\": calculated}\n</code></pre>"},{"location":"parallel/#dependent-dependencies","title":"Dependent Dependencies","text":"<p>Dependencies that depend on each other are resolved sequentially:</p> <pre><code>def get_user_id():\n    return 1\n\ndef get_user_data(user_id):\n    # This depends on get_user_id result\n    return {\"id\": user_id, \"name\": \"John\"}\n\n@app.get(\"/user\")\nasync def user(\n    user_id = get_user_id(),\n    user_data = get_user_data(user_id)  # Depends on user_id\n):\n    \"\"\"user_id resolves first, then user_data.\"\"\"\n    return user_data\n</code></pre>"},{"location":"parallel/#performance-benefits","title":"Performance Benefits","text":""},{"location":"parallel/#sequential-traditional","title":"Sequential (Traditional)","text":"<pre><code># Total time: 100ms + 150ms + 200ms = 450ms\nuser = get_user()        # 100ms\nstats = get_stats()      # 150ms\nnotifications = get_notifications()  # 200ms\n</code></pre>"},{"location":"parallel/#parallel-qakeapi","title":"Parallel (QakeAPI)","text":"<pre><code># Total time: max(100ms, 150ms, 200ms) = 200ms\n# 55% faster!\n@app.get(\"/dashboard\")\nasync def dashboard(\n    user = get_user(),           # 100ms\n    stats = get_stats(),         # 150ms\n    notifications = get_notifications()  # 200ms\n):\n    # All execute in parallel\n    pass\n</code></pre>"},{"location":"parallel/#best-practices","title":"Best Practices","text":"<ol> <li>Use for independent operations - parallel execution only helps if operations are independent</li> <li>Avoid side effects - dependencies should be pure functions when possible</li> <li>Use async for I/O - async dependencies are more efficient for I/O operations</li> <li>Document dependencies - make it clear what each dependency does</li> <li>Handle errors - dependencies can fail, handle errors appropriately</li> </ol>"},{"location":"parallel/#limitations","title":"Limitations","text":"<ul> <li>Dependencies must be callable (functions or callable objects)</li> <li>Circular dependencies are not supported</li> <li>Dependencies with complex interdependencies may not parallelize optimally</li> </ul>"},{"location":"pipelines/","title":"Pipelines","text":"<p>QakeAPI supports function pipelines for composing complex processing workflows.</p>"},{"location":"pipelines/#basic-pipeline","title":"Basic Pipeline","text":"<p>Create a pipeline of processing steps:</p> <pre><code>from qakeapi import QakeAPI\n\napp = QakeAPI()\n\ndef authenticate(request):\n    \"\"\"Step 1: Authenticate user.\"\"\"\n    token = request.headers.get(\"Authorization\")\n    if not token:\n        raise ValueError(\"Unauthorized\")\n    return {\"user_id\": 1, \"token\": token}\n\ndef authorize(data):\n    \"\"\"Step 2: Check permissions.\"\"\"\n    if data[\"user_id\"] != 1:\n        raise ValueError(\"Forbidden\")\n    return data\n\ndef validate(data):\n    \"\"\"Step 3: Validate data.\"\"\"\n    if \"name\" not in data:\n        raise ValueError(\"Name required\")\n    return data\n\ndef save(data):\n    \"\"\"Step 4: Save to database.\"\"\"\n    return {\"id\": 1, \"saved\": True}\n\n@app.pipeline([authenticate, authorize, validate, save])\ndef create_resource(request):\n    \"\"\"Pipeline executes all steps in sequence.\"\"\"\n    return {\"status\": \"created\"}\n</code></pre>"},{"location":"pipelines/#pipeline-execution","title":"Pipeline Execution","text":"<p>Pipelines execute steps sequentially, passing data from one step to the next:</p> <pre><code>def step1(data):\n    return {\"step1\": \"done\", **data}\n\ndef step2(data):\n    return {\"step2\": \"done\", **data}\n\ndef step3(data):\n    return {\"step3\": \"done\", **data}\n\n@app.pipeline([step1, step2, step3])\ndef process(data):\n    \"\"\"Each step receives output from previous step.\"\"\"\n    return data\n</code></pre>"},{"location":"pipelines/#error-handling","title":"Error Handling","text":"<p>Handle errors in pipeline steps:</p> <pre><code>def validate(data):\n    if not data.get(\"email\"):\n        raise ValueError(\"Email required\")\n    return data\n\n@app.pipeline([validate, save])\ndef create_user(data):\n    try:\n        return {\"status\": \"created\"}\n    except ValueError as e:\n        return {\"error\": str(e)}, 400\n</code></pre>"},{"location":"pipelines/#async-steps","title":"Async Steps","text":"<p>Pipeline steps can be async:</p> <pre><code>async def fetch_user_data(user_id):\n    # Async operation\n    return await database.get_user(user_id)\n\nasync def send_notification(user_data):\n    # Async operation\n    await email_service.send(user_data[\"email\"])\n\n@app.pipeline([fetch_user_data, send_notification])\nasync def process_user(user_id):\n    \"\"\"Async steps execute sequentially.\"\"\"\n    return {\"processed\": True}\n</code></pre>"},{"location":"pipelines/#mixed-syncasync","title":"Mixed Sync/Async","text":"<p>Mix sync and async steps:</p> <pre><code>def validate(data):\n    # Sync validation\n    if not data.get(\"name\"):\n        raise ValueError(\"Name required\")\n    return data\n\nasync def save(data):\n    # Async save\n    await database.save(data)\n    return data\n\n@app.pipeline([validate, save])\nasync def create(data):\n    \"\"\"Sync and async steps work together.\"\"\"\n    return {\"created\": True}\n</code></pre>"},{"location":"pipelines/#conditional-steps","title":"Conditional Steps","text":"<p>Skip steps based on conditions:</p> <pre><code>def should_process(data):\n    return data.get(\"process\", False)\n\ndef process_step(data):\n    if not should_process(data):\n        return data  # Skip processing\n    # Process data\n    return {\"processed\": True, **data}\n\n@app.pipeline([process_step, save])\ndef handle(data):\n    return data\n</code></pre>"},{"location":"pipelines/#use-cases","title":"Use Cases","text":""},{"location":"pipelines/#1-request-processing","title":"1. Request Processing","text":"<pre><code>@app.pipeline([\n    authenticate,\n    authorize,\n    validate_request,\n    transform_data,\n    save_to_db\n])\ndef create_item(request):\n    return {\"status\": \"created\"}\n</code></pre>"},{"location":"pipelines/#2-data-transformation","title":"2. Data Transformation","text":"<pre><code>@app.pipeline([\n    fetch_raw_data,\n    clean_data,\n    transform_format,\n    validate_schema,\n    save_transformed\n])\ndef process_data(source):\n    return {\"processed\": True}\n</code></pre>"},{"location":"pipelines/#3-multi-step-validation","title":"3. Multi-Step Validation","text":"<pre><code>@app.pipeline([\n    validate_format,\n    validate_content,\n    validate_business_rules,\n    check_permissions\n])\ndef validate_complete(data):\n    return {\"valid\": True}\n</code></pre>"},{"location":"pipelines/#best-practices","title":"Best Practices","text":"<ol> <li>Keep steps focused - each step should do one thing</li> <li>Handle errors - validate and handle errors at each step</li> <li>Use type hints - helps with data flow understanding</li> <li>Document steps - explain what each step does</li> <li>Test steps independently - easier to debug and test</li> </ol>"},{"location":"reactive/","title":"Reactive System","text":"<p>QakeAPI includes a reactive event system that allows you to build event-driven applications.</p> <p>Why QakeAPI events: Built-in <code>emit</code>/<code>react</code> \u2014 no Celery, Redis, or Kafka for simple flows. In-process event bus; zero network latency. Decouple handlers (email, analytics, inventory) from request handlers. For high-scale pub/sub, add Redis later; for most APIs, in-process is enough and faster.</p>"},{"location":"reactive/#event-emitting","title":"Event Emitting","text":"<p>Emit events from anywhere in your application:</p> <pre><code>from qakeapi import QakeAPI\n\napp = QakeAPI()\n\n@app.post(\"/orders\")\nasync def create_order(request):\n    data = await request.json()\n    order = create_order_in_db(data)\n\n    # Emit event\n    await app.emit(\"order:created\", {\n        \"order_id\": order.id,\n        \"user_id\": order.user_id,\n        \"items\": order.items\n    })\n\n    return {\"order_id\": order.id}\n</code></pre>"},{"location":"reactive/#event-reactors","title":"Event Reactors","text":"<p>React to events using decorators:</p> <pre><code>@app.react(\"order:created\")\nasync def on_order_created(event):\n    \"\"\"React to order creation event.\"\"\"\n    order_data = event.data\n\n    # Send confirmation email\n    await send_email(order_data[\"user_id\"], \"Order created\")\n\n    # Update inventory\n    await update_inventory(order_data[\"items\"])\n\n    # Schedule shipping\n    await schedule_shipping(order_data[\"order_id\"])\n</code></pre>"},{"location":"reactive/#multiple-reactors","title":"Multiple Reactors","text":"<p>Multiple reactors can listen to the same event:</p> <pre><code>@app.react(\"order:created\")\nasync def send_confirmation_email(event):\n    await send_email(event.data[\"user_id\"])\n\n@app.react(\"order:created\")\nasync def update_analytics(event):\n    await analytics.track(\"order_created\", event.data)\n\n@app.react(\"order:created\")\nasync def notify_admin(event):\n    await notify_admin_panel(event.data)\n</code></pre>"},{"location":"reactive/#event-data","title":"Event Data","text":"<p>Access event data:</p> <pre><code>@app.react(\"user:registered\")\nasync def on_user_registered(event):\n    user_data = event.data\n\n    # event.data contains the data passed to emit()\n    user_id = user_data.get(\"user_id\")\n    email = user_data.get(\"email\")\n\n    # Process event\n    await create_user_profile(user_id)\n    await send_welcome_email(email)\n</code></pre>"},{"location":"reactive/#event-namespacing","title":"Event Namespacing","text":"<p>Use namespaces for better organization:</p> <pre><code># Order events\nawait app.emit(\"order:created\", data)\nawait app.emit(\"order:paid\", data)\nawait app.emit(\"order:shipped\", data)\n\n# User events\nawait app.emit(\"user:registered\", data)\nawait app.emit(\"user:logged_in\", data)\nawait app.emit(\"user:updated\", data)\n\n# React to namespaced events\n@app.react(\"order:*\")\nasync def handle_all_order_events(event):\n    \"\"\"React to all order events.\"\"\"\n    pass\n</code></pre>"},{"location":"reactive/#synchronous-reactors","title":"Synchronous Reactors","text":"<p>Reactors can be synchronous:</p> <pre><code>@app.react(\"order:created\")\ndef on_order_created_sync(event):\n    \"\"\"Synchronous reactor - automatically converted to async.\"\"\"\n    # This will run in thread pool\n    log_to_file(event.data)\n    update_cache(event.data)\n</code></pre>"},{"location":"reactive/#error-handling-in-reactors","title":"Error Handling in Reactors","text":"<p>Handle errors in reactors:</p> <pre><code>@app.react(\"order:created\")\nasync def on_order_created(event):\n    try:\n        await process_order(event.data)\n    except Exception as e:\n        # Log error but don't break the event chain\n        logger.error(f\"Error processing order: {e}\")\n        # Optionally emit error event\n        await app.emit(\"order:processing_error\", {\"error\": str(e)})\n</code></pre>"},{"location":"reactive/#use-cases","title":"Use Cases","text":""},{"location":"reactive/#1-email-notifications","title":"1. Email Notifications","text":"<pre><code>@app.react(\"user:registered\")\nasync def send_welcome_email(event):\n    await email_service.send_welcome(event.data[\"email\"])\n\n@app.react(\"order:completed\")\nasync def send_order_confirmation(event):\n    await email_service.send_confirmation(event.data)\n</code></pre>"},{"location":"reactive/#2-database-updates","title":"2. Database Updates","text":"<pre><code>@app.react(\"order:created\")\nasync def update_inventory(event):\n    for item in event.data[\"items\"]:\n        await inventory.decrement(item[\"product_id\"], item[\"quantity\"])\n</code></pre>"},{"location":"reactive/#3-analytics","title":"3. Analytics","text":"<pre><code>@app.react(\"user:action\")\nasync def track_analytics(event):\n    await analytics.track(event.data[\"action\"], event.data)\n</code></pre>"},{"location":"reactive/#4-cache-invalidation","title":"4. Cache Invalidation","text":"<pre><code>@app.react(\"user:updated\")\nasync def invalidate_cache(event):\n    await cache.delete(f\"user:{event.data['user_id']}\")\n</code></pre>"},{"location":"reactive/#best-practices","title":"Best Practices","text":"<ol> <li>Use descriptive event names with namespaces</li> <li>Keep reactors focused - one responsibility per reactor</li> <li>Handle errors gracefully - don't let one reactor break others</li> <li>Use async for I/O operations in reactors</li> <li>Document events - document what data each event contains</li> </ol>"},{"location":"routing/","title":"Routing Guide","text":"<p>QakeAPI provides flexible routing with support for path parameters, query parameters, and automatic body extraction.</p> <p>Why QakeAPI routing is faster: Trie-based lookup for static paths \u2014 O(path length) vs O(routes). 100 routes: QakeAPI ~1.2\u03bcs, FastAPI ~2.8\u03bcs, Flask ~45\u03bcs. Param routes use regex compiled once at startup. Conditional routes (<code>@app.when</code>) checked first for early exit. See benchmarks.</p>"},{"location":"routing/#basic-routing","title":"Basic Routing","text":""},{"location":"routing/#http-methods","title":"HTTP Methods","text":"<pre><code>from qakeapi import QakeAPI\n\napp = QakeAPI()\n\n@app.get(\"/users\")\ndef get_users():\n    return {\"users\": []}\n\n@app.post(\"/users\")\nasync def create_user(request):\n    data = await request.json()\n    return {\"message\": \"Created\", \"data\": data}\n\n@app.put(\"/users/{id}\")\nasync def update_user(id: int, request):\n    data = await request.json()\n    return {\"id\": id, \"data\": data}\n\n@app.delete(\"/users/{id}\")\ndef delete_user(id: int):\n    return {\"message\": f\"Deleted {id}\"}\n</code></pre>"},{"location":"routing/#path-parameters","title":"Path Parameters","text":"<p>Extract parameters from the URL path:</p> <pre><code>@app.get(\"/users/{id}\")\ndef get_user(id: int):\n    \"\"\"Type conversion is automatic.\"\"\"\n    return {\"id\": id}\n\n@app.get(\"/posts/{post_id}/comments/{comment_id}\")\ndef get_comment(post_id: int, comment_id: int):\n    return {\"post_id\": post_id, \"comment_id\": comment_id}\n</code></pre>"},{"location":"routing/#query-parameters","title":"Query Parameters","text":"<p>Access query parameters:</p> <pre><code>@app.get(\"/search\")\ndef search(q: str, limit: int = 10, offset: int = 0):\n    \"\"\"Query parameters with defaults.\"\"\"\n    return {\n        \"query\": q,\n        \"limit\": limit,\n        \"offset\": offset\n    }\n</code></pre> <p>Or access via request object:</p> <pre><code>@app.get(\"/search\")\ndef search(request):\n    q = request.get_query_param(\"q\")\n    limit = int(request.get_query_param(\"limit\", default=\"10\"))\n    return {\"query\": q, \"limit\": limit}\n</code></pre>"},{"location":"routing/#request-body","title":"Request Body","text":"<p>Automatic body extraction for POST, PUT, PATCH:</p> <pre><code>@app.post(\"/users\")\nasync def create_user(request):\n    \"\"\"Access body via request object.\"\"\"\n    data = await request.json()\n    return {\"created\": data}\n\n# Or use automatic extraction with models\nclass UserCreate:\n    def __init__(self, name: str, email: str):\n        self.name = name\n        self.email = email\n\n@app.post(\"/users\")\nasync def create_user(user: UserCreate):\n    \"\"\"Body automatically extracted and converted.\"\"\"\n    return {\"name\": user.name, \"email\": user.email}\n</code></pre>"},{"location":"routing/#conditional-routing","title":"Conditional Routing","text":"<p>Route based on request conditions:</p> <pre><code>@app.when(lambda req: req.headers.get(\"X-Client\") == \"mobile\")\ndef mobile_handler(request):\n    return {\"client\": \"mobile\"}\n\n@app.when(lambda req: req.path.startswith(\"/api/v2\"))\ndef v2_handler(request):\n    return {\"version\": \"2.0\"}\n</code></pre>"},{"location":"routing/#route-names","title":"Route Names","text":"<p>Name your routes for easy reference:</p> <pre><code>@app.get(\"/users/{id}\", name=\"get_user\")\ndef get_user(id: int):\n    return {\"id\": id}\n</code></pre>"},{"location":"routing/#response-status-codes","title":"Response Status Codes","text":"<p>Return custom status codes:</p> <pre><code>@app.post(\"/users\")\nasync def create_user(request):\n    data = await request.json()\n    # Return tuple (data, status_code)\n    return {\"id\": 1, \"name\": data[\"name\"]}, 201\n\n@app.get(\"/not-found\")\ndef not_found():\n    return {\"error\": \"Not found\"}, 404\n</code></pre>"},{"location":"routing/#error-handling","title":"Error Handling","text":"<p>Handle errors in routes:</p> <pre><code>@app.get(\"/users/{id}\")\ndef get_user(id: int):\n    if id &lt; 0:\n        return {\"error\": \"Invalid ID\"}, 400\n\n    try:\n        user = database.get_user(id)\n        return user\n    except UserNotFound:\n        return {\"error\": \"User not found\"}, 404\n</code></pre>"},{"location":"routing/#routing-performance","title":"Routing Performance","text":"<p>QakeAPI uses an optimized routing system with Trie-based lookup for static routes:</p> <ul> <li>Static routes (without parameters) are matched in O(m) time where m is the path length</li> <li>Dynamic routes (with parameters like <code>/users/{id}</code>) use regex matching</li> <li>Routes are automatically categorized for optimal performance</li> <li>No changes needed in your code - optimization is transparent</li> </ul> <p>Example:</p> <pre><code># Static route - fast Trie lookup\n@app.get(\"/api/users\")\ndef get_users():\n    return {\"users\": []}\n\n# Dynamic route - regex matching\n@app.get(\"/api/users/{id}\")\ndef get_user(id: int):\n    return {\"id\": id}\n</code></pre>"},{"location":"routing/#dependency-injection","title":"Dependency Injection","text":"<p>Use dependency injection to simplify testing and code organization:</p> <pre><code>from qakeapi import QakeAPI, Depends\n\napp = QakeAPI()\n\ndef get_database():\n    return Database()\n\ndef get_current_user(request):\n    token = request.headers.get(\"Authorization\")\n    return decode_token(token)\n\n@app.get(\"/users/{id}\")\nasync def get_user(id: int, db = Depends(get_database), user = Depends(get_current_user)):\n    return await db.get_user(id, user_id=user.id)\n\n# With caching (dependency resolved once and cached)\ndef get_config():\n    return load_config()\n\n@app.get(\"/settings\")\nasync def get_settings(config = Depends(get_config, cache=True)):\n    return config\n</code></pre> <p>Benefits: - Testability - easy to mock dependencies - Reusability - share dependencies across routes - Clean architecture - separation of concerns - Caching - cache expensive dependency resolutions</p>"},{"location":"routing/#best-practices","title":"Best Practices","text":"<ol> <li>Use type hints for automatic validation and conversion</li> <li>Use async for I/O operations</li> <li>Use sync for CPU-bound operations (automatically parallelized)</li> <li>Return appropriate status codes</li> <li>Document your routes with docstrings (appears in Swagger UI)</li> <li>Use Dependency Injection for shared resources (database, config, etc.)</li> <li>Prefer static routes when possible for better performance</li> </ol>"},{"location":"tutorial/","title":"QakeAPI Tutorial: From Zero to Deploy","text":"<p>This tutorial walks you through building a REST API with QakeAPI from scratch to deployment.</p>"},{"location":"tutorial/#step-1-installation","title":"Step 1: Installation","text":"<pre><code>pip install qakeapi uvicorn\n</code></pre>"},{"location":"tutorial/#step-2-create-your-first-endpoint","title":"Step 2: Create Your First Endpoint","text":"<p>Create <code>main.py</code>:</p> <pre><code>from qakeapi import QakeAPI\n\napp = QakeAPI(title=\"My API\", version=\"1.0.0\")\n\n@app.get(\"/\")\ndef root():\n    return {\"message\": \"Hello, QakeAPI!\"}\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>Run:</p> <pre><code>python main.py\n</code></pre> <p>Visit <code>http://localhost:8000/</code> and <code>http://localhost:8000/docs</code> for Swagger UI.</p>"},{"location":"tutorial/#step-3-add-path-and-query-parameters","title":"Step 3: Add Path and Query Parameters","text":"<pre><code>@app.get(\"/users/{id}\")\ndef get_user(id: int):\n    return {\"id\": id, \"name\": f\"User {id}\"}\n\n@app.get(\"/search\")\ndef search(q: str, limit: int = 10):\n    return {\"query\": q, \"limit\": limit, \"results\": []}\n</code></pre>"},{"location":"tutorial/#step-4-add-post-with-request-body","title":"Step 4: Add POST with Request Body","text":"<pre><code>@app.post(\"/users\")\nasync def create_user(request):\n    data = await request.json()\n    return {\"message\": \"Created\", \"data\": data}\n</code></pre>"},{"location":"tutorial/#step-5-add-cors-and-middleware","title":"Step 5: Add CORS and Middleware","text":"<pre><code>from qakeapi import QakeAPI, CORSMiddleware, LoggingMiddleware\n\napp = QakeAPI(title=\"My API\", version=\"1.0.0\")\napp.add_middleware(CORSMiddleware(allow_origins=[\"*\"]))\napp.add_middleware(LoggingMiddleware())\n</code></pre>"},{"location":"tutorial/#step-6-add-dependency-injection","title":"Step 6: Add Dependency Injection","text":"<pre><code>from qakeapi import Depends\n\ndef get_db():\n    return {\"connection\": \"sqlite\"}\n\n@app.get(\"/users\")\ndef get_users(db = Depends(get_db)):\n    return {\"users\": [], \"db\": db}\n</code></pre>"},{"location":"tutorial/#step-7-add-caching","title":"Step 7: Add Caching","text":"<pre><code>from qakeapi import cache\n\n@cache(ttl=60)\n@app.get(\"/expensive\")\ndef expensive():\n    return {\"result\": \"computed\"}\n</code></pre>"},{"location":"tutorial/#step-8-add-rate-limiting","title":"Step 8: Add Rate Limiting","text":"<pre><code>from qakeapi import rate_limit\n\n@rate_limit(requests_per_minute=60)\n@app.get(\"/api/data\")\ndef get_data():\n    return {\"data\": \"...\"}\n</code></pre>"},{"location":"tutorial/#step-9-add-background-tasks","title":"Step 9: Add Background Tasks","text":"<pre><code>from qakeapi.core.background import add_background_task\n\n@app.post(\"/process\")\nasync def process(request):\n    data = await request.json()\n    await add_background_task(send_email, data[\"email\"])\n    return {\"status\": \"processing\"}\n</code></pre>"},{"location":"tutorial/#step-10-deploy-with-docker","title":"Step 10: Deploy with Docker","text":"<p>Create <code>Dockerfile</code>:</p> <pre><code>FROM python:3.11-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nCOPY . .\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre> <p>Create <code>requirements.txt</code>:</p> <pre><code>qakeapi\nuvicorn[standard]\n</code></pre> <p>Build and run:</p> <pre><code>docker build -t my-api .\ndocker run -p 8000:8000 my-api\n</code></pre>"},{"location":"tutorial/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started</li> <li>API Reference</li> <li>Benchmarks</li> <li>Ecosystem</li> </ul>"},{"location":"websocket/","title":"WebSocket Support","text":"<p>QakeAPI includes built-in WebSocket support for real-time communication.</p> <p>Why QakeAPI WebSockets: Native ASGI \u2014 no <code>websockets</code> or <code>python-socketio</code> package. <code>iter_json()</code> helper for clean message loops. Benchmarks: ~1.2K connections/sec vs Flask-SocketIO ~450. See benchmarks.</p>"},{"location":"websocket/#basic-websocket","title":"Basic WebSocket","text":"<p>Create a WebSocket endpoint:</p> <pre><code>from qakeapi import QakeAPI\nfrom qakeapi.core.websocket import WebSocket\n\napp = QakeAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_handler(websocket: WebSocket):\n    \"\"\"Basic WebSocket handler.\"\"\"\n    await websocket.accept()\n    await websocket.send_json({\"message\": \"Connected\"})\n\n    async for message in websocket.iter_json():\n        await websocket.send_json({\"echo\": message})\n</code></pre>"},{"location":"websocket/#websocket-with-path-parameters","title":"WebSocket with Path Parameters","text":"<p>Extract path parameters:</p> <pre><code>@app.websocket(\"/ws/{room}\")\nasync def room_handler(websocket: WebSocket, room: str):\n    \"\"\"WebSocket with path parameter.\"\"\"\n    await websocket.accept()\n    await websocket.send_json({\"message\": f\"Welcome to {room}!\"})\n\n    async for message in websocket.iter_json():\n        await websocket.send_json({\n            \"room\": room,\n            \"message\": message\n        })\n</code></pre>"},{"location":"websocket/#sending-messages","title":"Sending Messages","text":"<p>Send different message types:</p> <pre><code>@app.websocket(\"/ws\")\nasync def chat_handler(websocket: WebSocket):\n    await websocket.accept()\n\n    # Send JSON\n    await websocket.send_json({\"type\": \"welcome\", \"message\": \"Hello\"})\n\n    # Send text\n    await websocket.send_text(\"Text message\")\n\n    # Send bytes\n    await websocket.send_bytes(b\"Binary data\")\n</code></pre>"},{"location":"websocket/#receiving-messages","title":"Receiving Messages","text":"<p>Receive different message types:</p> <pre><code>@app.websocket(\"/ws\")\nasync def handler(websocket: WebSocket):\n    await websocket.accept()\n\n    # Receive JSON\n    async for message in websocket.iter_json():\n        await websocket.send_json({\"echo\": message})\n\n    # Receive text\n    async for message in websocket.iter_text():\n        await websocket.send_text(f\"Echo: {message}\")\n\n    # Receive bytes\n    async for message in websocket.iter_bytes():\n        await websocket.send_bytes(message)\n</code></pre>"},{"location":"websocket/#error-handling","title":"Error Handling","text":"<p>Handle WebSocket errors:</p> <pre><code>@app.websocket(\"/ws\")\nasync def handler(websocket: WebSocket):\n    try:\n        await websocket.accept()\n\n        async for message in websocket.iter_json():\n            try:\n                # Process message\n                await process_message(message)\n                await websocket.send_json({\"status\": \"ok\"})\n            except ValueError as e:\n                await websocket.send_json({\"error\": str(e)})\n    except Exception as e:\n        print(f\"WebSocket error: {e}\")\n    finally:\n        await websocket.close()\n</code></pre>"},{"location":"websocket/#broadcasting","title":"Broadcasting","text":"<p>Broadcast messages to multiple clients:</p> <pre><code># Store connected clients\nclients = set()\n\n@app.websocket(\"/ws\")\nasync def broadcast_handler(websocket: WebSocket):\n    await websocket.accept()\n    clients.add(websocket)\n\n    try:\n        async for message in websocket.iter_json():\n            # Broadcast to all clients\n            for client in clients:\n                try:\n                    await client.send_json(message)\n                except Exception:\n                    clients.remove(client)\n    finally:\n        clients.remove(websocket)\n        await websocket.close()\n</code></pre>"},{"location":"websocket/#room-based-chat","title":"Room-based Chat","text":"<p>Implement room-based chat:</p> <pre><code>rooms = defaultdict(set)\n\n@app.websocket(\"/ws/{room}\")\nasync def room_chat(websocket: WebSocket, room: str):\n    await websocket.accept()\n    rooms[room].add(websocket)\n\n    try:\n        async for message in websocket.iter_json():\n            # Broadcast to room\n            for client in rooms[room]:\n                if client != websocket:\n                    try:\n                        await client.send_json(message)\n                    except Exception:\n                        rooms[room].remove(client)\n    finally:\n        rooms[room].remove(websocket)\n        await websocket.close()\n</code></pre>"},{"location":"websocket/#connection-status","title":"Connection Status","text":"<p>Check connection status:</p> <pre><code>@app.websocket(\"/ws\")\nasync def handler(websocket: WebSocket):\n    await websocket.accept()\n\n    # Check if connected\n    if websocket.client_state == \"CONNECTED\":\n        await websocket.send_json({\"status\": \"connected\"})\n\n    async for message in websocket.iter_json():\n        # Process message\n        pass\n</code></pre>"},{"location":"websocket/#use-cases","title":"Use Cases","text":""},{"location":"websocket/#1-real-time-notifications","title":"1. Real-time Notifications","text":"<pre><code>@app.websocket(\"/ws/notifications/{user_id}\")\nasync def notifications(websocket: WebSocket, user_id: int):\n    await websocket.accept()\n\n    # Send notifications as they arrive\n    async for notification in get_notifications(user_id):\n        await websocket.send_json(notification)\n</code></pre>"},{"location":"websocket/#2-live-updates","title":"2. Live Updates","text":"<pre><code>@app.websocket(\"/ws/updates\")\nasync def live_updates(websocket: WebSocket):\n    await websocket.accept()\n\n    while True:\n        updates = await get_updates()\n        await websocket.send_json(updates)\n        await asyncio.sleep(1)\n</code></pre>"},{"location":"websocket/#3-chat-application","title":"3. Chat Application","text":"<pre><code>@app.websocket(\"/ws/chat/{room}\")\nasync def chat(websocket: WebSocket, room: str):\n    await websocket.accept()\n\n    async for message in websocket.iter_json():\n        # Save message\n        await save_message(room, message)\n\n        # Broadcast to room\n        await broadcast_to_room(room, message)\n</code></pre>"},{"location":"websocket/#best-practices","title":"Best Practices","text":"<ol> <li>Handle disconnections - clients can disconnect at any time</li> <li>Clean up resources - remove clients from sets/lists on disconnect</li> <li>Handle errors - wrap operations in try/except</li> <li>Use async - WebSocket operations are async</li> <li>Close connections - always close WebSocket in finally block</li> </ol>"}]}